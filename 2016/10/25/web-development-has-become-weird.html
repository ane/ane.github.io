<!-- -*- engine:liquid -*- -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <link href="https://micro.blog/ane" rel="me" />
    <link rel="webmention" href="https://micro.blog/webmention" />

    <title>
      
        Web development has become weird
      
    </title>

    
      <meta name="description" content="" />
    
    <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml" />

    <link type="application/atom+xml" rel="alternate" href="http://ane.iki.fi/feed.xml" title="Antoine Kalmbach's website" />
    <meta http-equiv="refresh" content="0; url=http://ane.iki.fi/2016/10/25/web-development-has-become-weird.html" />
    <link rel="canonical" href="http://ane.iki.fi/2016/10/25/web-development-has-become-weird.html"/>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Web development has become weird | Antoine Kalmbach’s website</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Web development has become weird" />
<meta name="author" content="Antoine Kalmbach" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Call me old-fashioned, call me a curmudgeon, but I think web development has become stupid and superficial. The unending quest towards single-page apps (SPAs) has made web development extremely painful and the current trend is diverging towards seven different directions at once. On one end, we have rich SPAs that can be built as native applications, on the other we have something completely orthogonal, of which a schism is beginning to form." />
<meta property="og:description" content="Call me old-fashioned, call me a curmudgeon, but I think web development has become stupid and superficial. The unending quest towards single-page apps (SPAs) has made web development extremely painful and the current trend is diverging towards seven different directions at once. On one end, we have rich SPAs that can be built as native applications, on the other we have something completely orthogonal, of which a schism is beginning to form." />
<link rel="canonical" href="http://ane.iki.fi/2016/10/25/web-development-has-become-weird.html" />
<meta property="og:url" content="http://ane.iki.fi/2016/10/25/web-development-has-become-weird.html" />
<meta property="og:site_name" content="Antoine Kalmbach’s website" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-10-25T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Web development has become weird" />
<meta name="twitter:site" content="@anewtf" />
<meta name="twitter:creator" content="@Antoine Kalmbach" />
<script type="application/ld+json">
{"headline":"Web development has become weird","dateModified":"2016-10-26T09:07:01+00:00","datePublished":"2016-10-25T00:00:00+00:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://ane.iki.fi/2016/10/25/web-development-has-become-weird.html"},"url":"http://ane.iki.fi/2016/10/25/web-development-has-become-weird.html","author":{"@type":"Person","name":"Antoine Kalmbach"},"description":"Call me old-fashioned, call me a curmudgeon, but I think web development has become stupid and superficial. The unending quest towards single-page apps (SPAs) has made web development extremely painful and the current trend is diverging towards seven different directions at once. On one end, we have rich SPAs that can be built as native applications, on the other we have something completely orthogonal, of which a schism is beginning to form.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/override.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="/assets/pygments.css" type="text/css" media="screen" />
  </head>
  <body itemscope itemtype="https://schema.org/WebPage" class="home-template">
    <div class="hyphenate">
      <h1 style="text-align: center;">
  Antoine Kalmbach
</h1>
<nav class="navbar">
  <ul>
    <li class="nav-item ">
      <a class="nav-link pl-0" href="/" itemprop="url"><span itemprop="name">Home</span></a>
    </li>
    <li class="nav-item  active">
      <a class="nav-link" href="/archive.html" itemprop="url"><span itemprop="name">Blog</span></a>
    </li>
    <li class="nav-item ">
      <a class="nav-link" href="/about/" itemprop="url"><span itemprop="name">About</span></a>
    </li>
    <li class="nav-item ">
      <a class="nav-link" href="/tags.html" itemprop="url"><span itemprop="name">Index</span></a>
    </li>

    <li class="nav-item mr-n2">
      <a class="nav-link" href="/feed.xml"><i class="fa fa-rss" aria-hidden="true"></i> RSS</a>
    </li>
  </ul>
</nav>

<div class="h-card d-none" style="display: none">
  <img class="u-photo" src="/images/me.png" />
  <a class="u-url" href="http://ane.iki.fi/2016/10/25/web-development-has-become-weird.html"></a>
  <a class="p-name u-url" href="http://ane.iki.fi">Antoine Kalmbach</a>
  <a class="u-email" href="mailto:">ane@iki.fi</a>
</div>


      <div class="content">
        <article class="h-entry">
  <header>
    





  <h2 class="p-name" style="margin: 0.25rem 0;">
    Web development has become weird
  </h2>

  <p class="post-meta text-muted">
    <time class="dt-published" itemprop="datePublished" datetime="2016-10-25 00:00:00 +0000">
      Posted on October 25, 2016

  </p>


    <link itemprop="mainEntityOfPage" itemscope itemtype="http://schema.org/BlogPosting" href="/2016/10/25/web-development-has-become-weird.html" />
  </header>
  <div class="e-content">
    <p>Call me old-fashioned, call me a curmudgeon, but I think web development has become stupid and
superficial. The unending quest towards single-page apps (SPAs) has made web development extremely
painful and the current trend is diverging towards seven different directions at once. On one end,
we have rich SPAs that can be built as native applications, on the other we have
something <a href="https://github.com/ampproject/amphtml">completely orthogonal</a>, of which
a <a href="https://timkadlec.com/2016/02/a-standardized-alternative-to-amp/">schism</a> is beginning to form.</p>

<!--break-->

<p>The underlying problem is unfortunately that the web is being misused as an application container
instead of the original text transport protocol it was made to be. It’s no use crying over spilled
milk; the web has been subverted, transformed, improved upon, so much so we don’t know what the
original even <a href="http://wiki.c2.com/">looked like</a>.</p>

<h2 id="how-it-was">How it was</h2>

<p>In 2006, the hot new thing was Ruby on Rails or Django. If you weren’t using them, odds were you
were using PHP or ASP.NET. Most intranet software ran on SharePoint or, I kid you not,
WordPress. Users didn’t really care either way.</p>

<p>People liked Rails and Django because they made web development stupidly simple. No more SQL, just
create your models and migrations. An architecture that made sense, MVC, was applied, and web apps
became a little bit better. Meanwhile, the overall web development experience got a <em>lot</em> better.</p>

<p>Of course, the web was slower back then. Chrome wasn’t around, so JavaScript usage was very
limited. Google began prototyping under-the-hood requests in Gmail around 2006, but before that
nobody had heard of AJAX. The concept of doing more than one page request per page load was
completely unheard of. The users liked faster page loads, so when Chrome came around with V8,
customers started suddenly giving a shit about what browser they used.</p>

<h2 id="where-it-all-began">Where it all began</h2>

<p>On the surface, the appeal in SPAs was obvious. It started with Gmail and AJAX. No more slow page
loads, the applications behaved like native applications, and soon they even
<a href="http://getbootstrap.com">looked</a> like them! Innovative as that was, now we’re beginning to use so many
web applications that are in the web <em>only</em> that we’re slowly starting to forget what the native app
experience <em>was</em>.</p>

<p>The problem was that it wasn’t enough, you needed a <em>backend</em>. Before, when there was one
application, now there were <em>two</em>, and they usually were completely different from each other. The
backend–front-end split was fuzzy to begin with, this introduced an uncertainty and a possibly
pointless abstraction. Put the “slow” and “heavy” things to the backend, let the front-end handle
rendering and the user interface, all the backend had to do was supply serialized data. Even back then, people started asking
questions about the SEO effects of rendering a page entirely in JavaScript. No solution was given,
although one solution <a href="https://www.meteor.com/">existed, but was weird</a>.</p>

<p>So while the backend folks built eleventy versions of <a href="http://www.sinatrarb.com/">Sinatra</a>, the
front-end folks got busy. In a short time we had Backbone, Angular, and Knockout, then we got
frameworks like Durandal and Meteor.js. Finally, Facebook looked at the performance of desktop applications, then looked
at the performance of web applications, thought, “holy shit”, and
<a href="https://facebook.github.io/react/">did something about it</a>.</p>

<p>People got scared. It was mixing business and presentation logic, they said. It was mixing JavaScript
with something eerily like XML, and everyone said XML sucked. Then people got over their
usual trepidation towards $newTechnologyOfTheYear and got on with their lives. Now React is being
used <a href="http://www.facebook.com">left</a> and <a href="https://www.reddit.com/r/reactjs/comments/4iei7s/twitters_new_mobile_site_is_using_react_redux_and/">right</a>.</p>

<p>The only problem was, React was a templating engine at heart. Facebook did not build a bridge for
existing front-end frameworks, so that people could have just dropped in React instead of say,
Handlebars or even ERB. Facebook did not do this because they already had their
<a href="http://hacklang.org/">own way of rendering content</a>. They didn’t need one. Build your own, they
said.</p>

<p>Faced with just a templating engine, developers got confused. “How do I do routes with this?” they
asked. So we built <a href="https://github.com/ReactTraining/react-router">routing engines</a> and
<a href="https://github.com/reactjs/redux">state containers</a>, and got on with our lives. Soon after that,
someone understood
<a href="http://jamesknelson.com/universal-react-youre-doing-it-wrong/">React ran quite fine on a Node.js server</a>,
and people started
<a href="https://scotch.io/tutorials/react-on-the-server-for-beginners-build-a-universal-react-and-node-app">rendering pages in two places: the backend <em>and</em> the front-end</a>.</p>

<p>Now, people are using React – a JavaScript library to be run inside a browser – to create
<a href="https://facebook.github.io/react-native/">native mobile applications</a>. Meanwhile, other folks
think, all of this, this excession, is simply too much, and want <a href="https://www.ampproject.org/">pages to load quickly</a>.</p>

<p>Couple this with the at least
<a href="https://medium.com/@kitze/how-it-actually-feels-to-write-javascript-in-2016-46b5dda17bb5#.jnsf71d1l">bizarre</a>
experience of JavaScript development in 2016, things are looking weird. The tooling iterates at an
impossible speed, a new build system emerges every year, and developers must stay on top of things.</p>

<p>Having to stay on top of things is, generally, a good thing. Software progresses, it progresses so
fast that we <em>must</em> constantly learn for us to stay employable and the profession to stay
enjoyable. But at this speed, when it seems we’re not really learning from the past, it’s not doing
anyone any good. React took a good idea from desktop applications, event-driven user interface
rendering, and executed it brilliantly as they ported it to the web.</p>

<p>The thing is, it’s still <em>nothing</em> new. Ten years ago we were building crappy and weird-looking
software in C#, now we’re building crappy and broken software in a mix of JavaScript and other
languages, and they run in the browser, or on smartphones, and they’re responsive, so that when you
tilt your tablet sideways, that big fat menu disappears. Huh.</p>

<p>That’s what they call the churn.</p>

<p>The churn. New technologies come and they kill the old technologies, but in the midst of it all,
stand you and I, wondering what the hell to do with this mess. From the other side of it all, from
the ivory tower of the real world, the business analysts cast their shadow and remind us these
technologies are tools, they’re meant to be replaced, they’re <em>disposable</em>. So are we, if we can’t
learn new ones, they remind keep reminding us.</p>

<h2 id="so">So?</h2>

<p>I make it sound as if web development is impossible, but that couldn’t be further from the
truth. Browsers are getting better and faster. Our applications are prettier, faster, more
accessible, more usable. The web is replacing desktop applications and this trend is accelerating –
whether this is a good or bad thing, I don’t know.</p>

<p>The only problem is that the development experience keeps reinventing itself at such a pace you may
as well put yourself into stasis and wait for things to settle. Wait for front-end development to
become <em>boring</em>. Odds are you can sleep for quite a bit until that happens. The second option is
just to pick whatever works <em>right now</em> and use it.</p>

<p>The optimistic part is that we, as web developers, are learning, we’re doing some
<a href="https://clojurescript.org/">cool things</a> and <a href="http://udash.io/">unifying</a> two halves of the same
thing. The backend guys are <a href="http://mbrace.io/">innovating</a> and tooling progress is
<a href="http://mesos.apache.org/">insane</a> and <a href="http://kubernetes.io/">exciting</a>. So I cannot state that we
haven’t gotten anywhere, we <em>have</em> innovated, learned, and improved the Web. But by how much? Are
our end users happier?</p>

<h1 id="a-concrete-solution">A concrete solution</h1>

<p>Given the task of implementing a web application, what would I do, given the state of the art in
2016? I spent about four years developing SPAs with many frameworks. I hate them all. Given that
sentiment, this is what I would do:</p>

<ol>
  <li>Using a language of your choice, build a business logic API that can be used via REST or some
other RPC protocol. The language and its associated tooling should be performant and support
rapid iteration.</li>
  <li>Use a <a href="http://rubyonrails.org/">batteries-included</a> web framework, spiced with
a <a href="https://github.com/reactjs/react-rails">rendering framework</a> of your choice, to create front-end.</li>
  <li>Build many front-ends, not just for the web, but for mobile and perhaps even desktop, and keep
them thin.</li>
  <li>The web front-end can be spiced up (but not replaced) using JavaScript. Come to think of it, I
would have done the same thing in 2006.</li>
</ol>

<p>Point 4. originates from my experiences of creating and maintaining SPA applications. I think SPAs
are, by and large, a bogus concept. A web application loading another page isn’t intrinsically a bad
idea, if your application is fast enough. Conversely, if your SPA is slow, you’re doing it
wrong. SPAs were invented for speed, because conventional web frameworks were slow. This is not the
case anymore. Sure, you won’t see Rails, Django or Play beat the TechEmpower benchmarks, but we’ve
come a long way from five years ago, which is when people started to play around with SPAs.</p>

<p>Given the speed improvements, why not go full-stack? Why a front-end and a back-end?</p>

<p>The answer for this is not simple. It is because we’re dealing with two incompatible abstractions:</p>

<ol>
  <li>Building your application as an API means you need a client application to provide the user
interface.</li>
  <li>To build such an interface, your application has to deal with the fact that HTTP, and thus REST,
is stateless.</li>
  <li>Web applications are usually stateful.</li>
  <li>This leads inevitably to the requirement of building an abstraction in the middle that handles
client state, which your API does not support.</li>
  <li>Building such an abstraction – the front-end – requires a lot of work, e.g. by using a MVC (or
MVVM whatever) model. Double the work, half the fun.</li>
</ol>

<p>So, the back-end abstraction is incompatible with client state, but the front-end application
requires client state. Conversely, a full-stack application is often a heavy monolith: it needs to
handle data access, its modification and its presentation in the same package. Here, as they say, be
dragons. We want to keep business logic and presentation logic separate, hence, a full-stack
framework does not work on its own.</p>

<p>As a solution, I offer a synthesis. It’s mixing a REST back-end with a full-stack frontend. The
back-end can be built using whatever language is performant and maintainable. Build your front-end
with a boring framework like Rails, Django or Pyramid; let it fetch its data from the REST API,
i.e., treat the API as the data source. Let the front-end handle client state on its own. What you
get in return:</p>

<ol>
  <li>The ease of use of said framework. These frameworks were invented for a reason. You get routing,
templating, asset pipelines etc. out-of-the-box.</li>
  <li>You can still do AJAX
requests <a href="http://guides.rubyonrails.org/working_with_javascript_in_rails.html">easily</a> to build
rich user interfaces.</li>
  <li>A reusable API in the backend you can use in other applications, keep your web front-end an equal
citizen.</li>
</ol>

<p>If you don’t want to deal with framework bloat, or if you’re scared of non-JavaScript applications,
be my guest, build your own front-end using the essentials. Splurge in Gulp, ES6, React, and
Redux. Or use TypeScript. But I dare say, after having worked with both full-stack frameworks
(e.g. Rails) and SPA+REST frameworks, the compromise above is much more pleasant.</p>

<p>In the end though, it doesn’t really matter: with the exception of a few, our end users couldn’t
care less. They really don’t give a shit. So, pick whatever technology works for you and your
users. The above is just one option.</p>

  </div>
  <small style="display: flex; justify-content: space-between;">
    
      <em>
        Previous: <a href="/2016/10/14/communicator-functional-actors.html">Communicators: Actors with purely functional state</a>
      </em>
    

    
      <em>
        Next: <a href="/2016/11/02/half-stack-web-frameworks.html">Half stack web frameworks</a>
      </em>
    
  </small>
</article>

      </div>

      <footer>
        <hr>
        <address>
          
          

          &copy; <a href="mailto:ane@iki.fi">Antoine Kalmbach</a>, see <a href="/this-site/index.html#copying">copying</a>.
          Last updated on <a href="/changelog.html">July 28, 2021</a>. Discuss at my <a href="https://lists.sr.ht/~ane/public-inbox">public inbox</a>.
        </address>
      </footer>
    </div>
    <script src="/assets/hyphenator.js" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [ ['$','$'], ['\\(', '\\)'] ],
         processEscapes: false
       }
     });
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <script src="/assets/hylo.js" type="text/javascript"></script>
    <!-- Google Analytics Tracking code -->
    <script type="text/javascript">

     var _gaq = _gaq || [];
     _gaq.push(['_setAccount', 'UA-58162697-1']);
     _gaq.push(['_trackPageview']);

     (function () {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
     })();

    </script>
  </body>

</html>
