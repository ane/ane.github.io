<!-- -*- engine:liquid -*- -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <link href="https://micro.blog/ane" rel="me" />
    <link rel="webmention" href="https://micro.blog/webmention" />

    <title>
      
        Communicators: Actors with purely functional state
      
    </title>

    
      <meta name="description" content="or, why mutable state is dangerous">
    
    <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml" />

    <link type="application/atom+xml" rel="alternate" href="http://ane.iki.fi/feed.xml" title="Antoine Kalmbach's website" />
    <meta http-equiv="refresh" content="0; url=http://ane.iki.fi/2016/10/14/communicator-functional-actors.html" />
    <link rel="canonical" href="http://ane.iki.fi/2016/10/14/communicator-functional-actors.html"/>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Communicators: Actors with purely functional state | Antoine Kalmbach’s website</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Communicators: Actors with purely functional state" />
<meta name="author" content="Antoine Kalmbach" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In Scala, Akka actors, as in the traditional Actor model, may modify private state. The accepted convention is to have a mutable object (e.g. a Map), a var, and mutate it like so: class Library extends Actor { var books = scala.collection.mutable.Map.empty[String, String] def receive: Receive = { case AddBook(isbn, title) =&gt; books += (isbn -&gt; title) } } object Library { case class AddBook(isbn: String, title: String) } This is a bad idea. There are several reasons for this. First, Scala eschews vars, they should only be used when absolutely necessary (read: never). There is also an additional need for thread-safety for the collection, not because of the receive method itself." />
<meta property="og:description" content="In Scala, Akka actors, as in the traditional Actor model, may modify private state. The accepted convention is to have a mutable object (e.g. a Map), a var, and mutate it like so: class Library extends Actor { var books = scala.collection.mutable.Map.empty[String, String] def receive: Receive = { case AddBook(isbn, title) =&gt; books += (isbn -&gt; title) } } object Library { case class AddBook(isbn: String, title: String) } This is a bad idea. There are several reasons for this. First, Scala eschews vars, they should only be used when absolutely necessary (read: never). There is also an additional need for thread-safety for the collection, not because of the receive method itself." />
<link rel="canonical" href="http://ane.iki.fi/2016/10/14/communicator-functional-actors.html" />
<meta property="og:url" content="http://ane.iki.fi/2016/10/14/communicator-functional-actors.html" />
<meta property="og:site_name" content="Antoine Kalmbach’s website" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-10-14T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Communicators: Actors with purely functional state" />
<meta name="twitter:site" content="@anewtf" />
<meta name="twitter:creator" content="@Antoine Kalmbach" />
<script type="application/ld+json">
{"headline":"Communicators: Actors with purely functional state","dateModified":"2017-04-13T10:11:04+00:00","datePublished":"2016-10-14T00:00:00+00:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://ane.iki.fi/2016/10/14/communicator-functional-actors.html"},"url":"http://ane.iki.fi/2016/10/14/communicator-functional-actors.html","author":{"@type":"Person","name":"Antoine Kalmbach"},"description":"In Scala, Akka actors, as in the traditional Actor model, may modify private state. The accepted convention is to have a mutable object (e.g. a Map), a var, and mutate it like so: class Library extends Actor { var books = scala.collection.mutable.Map.empty[String, String] def receive: Receive = { case AddBook(isbn, title) =&gt; books += (isbn -&gt; title) } } object Library { case class AddBook(isbn: String, title: String) } This is a bad idea. There are several reasons for this. First, Scala eschews vars, they should only be used when absolutely necessary (read: never). There is also an additional need for thread-safety for the collection, not because of the receive method itself.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/override.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="/assets/pygments.css" type="text/css" media="screen" />
  </head>
  <body itemscope itemtype="https://schema.org/WebPage" class="home-template">
    <div class="hyphenate">
      <h1 style="text-align: center;">
  Antoine Kalmbach
</h1>
<nav class="navbar">
  <ul>
    <li class="nav-item ">
      <a class="nav-link pl-0" href="/" itemprop="url"><span itemprop="name">Home</span></a>
    </li>
    <li class="nav-item  active">
      <a class="nav-link" href="/archive.html" itemprop="url"><span itemprop="name">Blog</span></a>
    </li>
    <li class="nav-item ">
      <a class="nav-link" href="/about/" itemprop="url"><span itemprop="name">About</span></a>
    </li>
    <li class="nav-item ">
      <a class="nav-link" href="/tags.html" itemprop="url"><span itemprop="name">Index</span></a>
    </li>

    <li class="nav-item mr-n2">
      <a class="nav-link" href="/feed.xml"><i class="fa fa-rss" aria-hidden="true"></i> RSS</a>
    </li>
  </ul>
</nav>

<div class="h-card d-none" style="display: none">
  <img class="u-photo" src="/images/me.png">
  <a class="u-url" href="http://ane.iki.fi/2016/10/14/communicator-functional-actors.html"></a>
  <a class="p-name u-url" href="http://ane.iki.fi">Antoine Kalmbach</a>
  <a class="u-email" href="mailto:">ane@iki.fi</a>
</div>


      <div class="content">
        <article class="h-entry">
  <header>
    





  <h2 class="p-name" style="margin: 0.25rem 0;">
    Communicators: Actors with purely functional state
  </h2>

  <p class="post-meta text-muted">
    <time class="dt-published" itemprop="datePublished" datetime="2016-10-14 00:00:00 +0000">
      Posted on October 14, 2016

  </time></p>


    <link itemprop="mainEntityOfPage" itemscope itemtype="http://schema.org/BlogPosting" href="/2016/10/14/communicator-functional-actors.html">
  </header>
  <div class="e-content">
    <p>In Scala, Akka actors, as in the traditional <a href="http://en.wikipedia.org/wiki/Actor_model">Actor model</a>, may
modify private state. The accepted convention is to have a mutable object (e.g. a
<code class="language-plaintext highlighter-rouge">Map</code>), a <code class="language-plaintext highlighter-rouge">var</code>, and mutate it like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">books</span> <span class="k">=</span> <span class="nv">scala</span><span class="o">.</span><span class="py">collection</span><span class="o">.</span><span class="py">mutable</span><span class="o">.</span><span class="py">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span>
  
  <span class="k">def</span> <span class="nf">receive</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">books</span> <span class="o">+=</span> <span class="o">(</span><span class="n">isbn</span> <span class="o">-&gt;</span> <span class="n">title</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Library</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is a bad idea. There are several reasons for this. First, Scala eschews <code class="language-plaintext highlighter-rouge">var</code>s, they should
only be used when absolutely necessary (read: never). There is also an additional need for
thread-safety for the collection, not because of the <code class="language-plaintext highlighter-rouge">receive</code> method itself. <!--break-->The <code class="language-plaintext highlighter-rouge">receive</code> method
is
<a href="http://doc.akka.io/docs/akka/2.4.11/general/jmm.html">guaranteed to run inside a single thread</a>. However,
an unsuspecting user might still launch a <code class="language-plaintext highlighter-rouge">Future</code> and modify the collection, leading to
unpredictable behaviour. Such concurrent mutations on a <code class="language-plaintext highlighter-rouge">var</code> put strain on the garbage collector,
in fact, it often necessitates the existence of a garbage collector.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup> Lastly, as with any mutable
state and possible lack of referential transparency, the code can become hard to reason about.</p>

<p>Thankfully, Akka actors offer a possibility to do this completely functionally. The function
<code class="language-plaintext highlighter-rouge">context.become</code> allows an Actor to change its <code class="language-plaintext highlighter-rouge">receive</code> method on-the-fly. In other words, it lets
the Actor change its state and communication model. Here’s the above implemented using this
paradigm:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="nf">active</span><span class="o">(</span><span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>
  
  <span class="k">def</span> <span class="nf">active</span><span class="o">(</span><span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="c1">// for immutable maps, += returns a new collection</span>
      <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">active</span><span class="o">(</span><span class="n">books</span> <span class="o">+=</span> <span class="o">(</span><span class="n">isbn</span> <span class="o">-&gt;</span> <span class="n">title</span><span class="o">)))</span> 
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">active</code> function returns a new <code class="language-plaintext highlighter-rouge">Receive</code>, receiving the current actor <em>state</em> as its
parameter. Adding logic to it is now easy:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="nf">active</span><span class="o">(</span><span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>
  
  <span class="k">def</span> <span class="nf">active</span><span class="o">(</span><span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="nf">if</span> <span class="o">(</span><span class="nv">books</span><span class="o">.</span><span class="py">size</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
        <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">active</span><span class="o">(</span><span class="n">books</span> <span class="o">+=</span> <span class="o">(</span><span class="n">isbn</span> <span class="o">-&gt;</span> <span class="n">title</span><span class="o">)))</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nf">sender</span><span class="o">()</span> <span class="o">!</span> <span class="s">"Too many books"</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The above code is now thread-safe and doesn’t use mutable collections, but what if our logic gets
more complicated? What if we need to talk to another Actor, or talk to the sender of the message?
This is where we stumble upon a design feature of Akka: <em>all</em> of its Actors are actually compiled
down into a callback-based implementation. There is no guarantee that a <code class="language-plaintext highlighter-rouge">Future</code> launched in a
receive case will be running in the same thread as the next! One could argue that this is not a
feature but a <em>flaw</em>, but I won’t go that far. Hence, code dealing with Futures in Akka actors needs to deal with the unforgiving reality that there is no
guarantee of thread safety. Case in point:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span><span class="o">(</span><span class="n">popReservation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="nf">active</span><span class="o">(</span><span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>
  
  <span class="k">def</span> <span class="nf">active</span><span class="o">(</span><span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// as before</span>
    <span class="k">case</span> <span class="nc">AskForBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="nf">popReservation</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
        <span class="c1">// AAH!!!</span>
        <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">active</span><span class="o">(</span><span class="n">books</span> <span class="o">-</span> <span class="n">i</span><span class="o">))</span>
        <span class="nf">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">s</span><span class="s">"Here you go: $i"</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>Why am I screaming in the comments? First, as calling <code class="language-plaintext highlighter-rouge">map</code> for our Future launches a new thread, we
have no idea whether <code class="language-plaintext highlighter-rouge">sender()</code> returns the same value in the new thread, and second, we may be
modifying the books collection concurrently with other threads - leaving the garbage collector to
collect our mess. So we strain the GC <em>and</em> risk giving the book to the wrong caller!</p>

<p>Since the actual execution of a Future is left to the execution context, which in the case of Actors
is the <code class="language-plaintext highlighter-rouge">ActorSystem</code>s dispatcher, we may or may not be invoking <code class="language-plaintext highlighter-rouge">sender()</code> in the right thread
— there is simply no guarantee. We can’t reason about it, it has been hidden from us.</p>

<p>To deal with this, Akka has introduced the <code class="language-plaintext highlighter-rouge">pipe</code> pattern, which is an implicit given to Futures
which solves this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span><span class="o">(</span><span class="n">popReservation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="nf">active</span><span class="o">(</span><span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>
  
  <span class="k">def</span> <span class="nf">active</span><span class="o">(</span><span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// as before</span>
    <span class="k">case</span> <span class="nc">AskForBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="c1">// launch another thread</span>
      <span class="k">val</span> <span class="nv">reservation</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nf">popReservation</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
        <span class="n">s</span><span class="s">"Here you go: $i"</span>
        <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">active</span><span class="o">(</span><span class="n">books</span> <span class="o">-</span> <span class="n">isbn</span><span class="o">))</span> <span class="c1">// AAH!</span>
      <span class="o">}</span>
      <span class="c1">// but sender() is still the same</span>
      <span class="n">reservation</span> <span class="n">pipeTo</span> <span class="n">sender</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Another option is to fix the reference of <code class="language-plaintext highlighter-rouge">sender</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nf">sender</span><span class="o">()</span>
<span class="k">val</span> <span class="nv">reservation</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nf">popReservation</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
  <span class="n">s</span> <span class="o">!</span> <span class="n">s</span><span class="s">"Here you go: $i"</span>
  <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">active</span><span class="o">(</span><span class="n">books</span> <span class="o">-</span> <span class="n">isbn</span><span class="o">))</span> <span class="c1">// AAH!</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Ok, now we’ve fixed <code class="language-plaintext highlighter-rouge">sender()</code>, but what about the <code class="language-plaintext highlighter-rouge">books</code> collection? Let’s add a <code class="language-plaintext highlighter-rouge">PopBook(isbn:
String)</code> case class, and handle that for removals:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span><span class="o">(</span><span class="n">popReservation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="nf">active</span><span class="o">(</span><span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>
  
  <span class="k">def</span> <span class="nf">active</span><span class="o">(</span><span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// as before</span>
    <span class="k">case</span> <span class="nc">PopBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">active</span><span class="o">(</span><span class="n">books</span> <span class="o">-</span> <span class="n">isbn</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">AskForBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="c1">// launch another thread</span>
      <span class="k">val</span> <span class="nv">reservation</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nf">popReservation</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
        <span class="n">s</span><span class="s">"Here you go: $i"</span>
        <span class="n">self</span> <span class="o">!</span> <span class="nc">PopBook</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
      <span class="o">}</span>
      <span class="c1">// but sender() is still the same</span>
      <span class="n">reservation</span> <span class="n">pipeTo</span> <span class="n">sender</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Sending messages to <code class="language-plaintext highlighter-rouge">self</code> is always thread-safe - the reference does not change over time. So, at
this point, it seems clear that making actor code thread-<em>sane</em> involves the use of:</p>

<ul>
  <li>immutable state - call <code class="language-plaintext highlighter-rouge">context.become</code> with a closure over the new actor state,</li>
  <li>converting asynchronous state modifications as messages to be handled later, and</li>
  <li>making sure the <code class="language-plaintext highlighter-rouge">sender()</code> reference is consistent</li>
</ul>

<p>What about complicated states? What if we need to react differently to these messages, e.g., when
the library is closed? I sense that you’re about to mention Akka’s <code class="language-plaintext highlighter-rouge">FSM</code> construct, which
builds a state machine, encapsulating state and transitions to what is essentially syntactic sugar,
and on the surface, seems like a good idea.</p>

<h2 id="enter-akka-fsms">Enter Akka FSMs</h2>

<p>At a closer look, it essentially leads us to repeat the same mistakes as above, and the arguments
against it are argumented <a href="https://github.com/alexandru/scala-best-practices/blob/master/sections/5-actors.md#55-should-not-use-akka-fsm" target="_blank">here</a>. In
summary, it boils down to:</p>

<ol>
  <li>Akka FSM’s is too restrictive. You cannot handle multi-step or complicated state transitions, and
modeling undeterministic behaviour is impossible.</li>
  <li>You are tied to Akka completely, you must use Akka testkit for your tests. Anyone who has worked
with testkit knows this to be a burden.</li>
  <li>State transitions have identity instead of being truly functional, that is, FSMs alter the
<em>current</em> state instead of <em>producing</em> a new one.</li>
</ol>

<p>Moreover, and I think this is the biggest shortcoming, the Akka FSM are finite-state <em>automata</em>
— they are characterised by the state transition function <code class="language-plaintext highlighter-rouge">(Input, State) =&gt; State</code>. Since we
know actors are more about communication than anything else, this model is insufficient, and what we
need is a state machine that can produce <em>output</em>: a finite state <em>transducer</em>. Its state transition
function has the signature <code class="language-plaintext highlighter-rouge">(Input, State) =&gt; (Output, State)</code> - every transition produces an
output, and Scala can model this efficiently:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">FSA</span><span class="o">[</span><span class="kt">State</span>, <span class="kt">Input</span>, <span class="kt">Output</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">transition</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Output</span><span class="o">],</span> <span class="nc">State</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>With all these flaws, despite being a nice idea at a glance, it’s obvious that for any complicated
logic Akka FSM’s aren’t sufficient.</p>

<p>Let’s envision a radical version of actors, accounting for all the flaws described above:</p>

<ul>
  <li>State transitions should be about producing a new state, i.e. <code class="language-plaintext highlighter-rouge">(Input, State) =&gt; (Output, State)</code>
</li>
  <li>Actor computations will deal with asynchronous code, we must deal with this intelligently</li>
  <li>Keep I/O logic out of actors - the actor only communicates with the external world</li>
  <li>Actors should only mutate their state with with <code class="language-plaintext highlighter-rouge">context.become</code>
</li>
</ul>

<p>The last bullet point is especially important, as it constrains state changes
to be entirely functional, as you can simply make a function <code class="language-plaintext highlighter-rouge">def foo(state:
State): Receive</code>, and keep calling it recursively, by transitioning states
thusly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">active</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">)</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">someInput</span><span class="k">:</span> <span class="kt">Input</span> <span class="o">=&gt;</span> <span class="n">context</span> <span class="n">become</span> <span class="nf">active</span><span class="o">(</span><span class="n">state</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This idea is not new. Erlang actors have worked like this for actual decades,
and arguments for using this method in Scala can be found left and right, summarized particularly well in
Alexandru Nedelcu’s <a href="https://github.com/alexandru/scala-best-practices/blob/master/sections/5-actors.md#52-should-mutate-state-in-actors-only-with-contextbecome">Scala best practices</a>.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">active</span><span class="p">(</span><span class="nv">Sum</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="k">receive</span> 
    <span class="p">{</span><span class="nv">From</span><span class="p">,</span> <span class="nv">GetValue</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nv">From</span> <span class="o">!</span> <span class="nv">Sum</span><span class="p">;</span>
    <span class="p">{</span><span class="n">n</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nf">active</span><span class="p">(</span><span class="nv">Sum</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
  <span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>Putting emphasis on the last point, I’ve come up with a moniker called <em>communicators</em>.</p>

<h2 id="actor-meet-communicator">Actor, meet communicator</h2>

<p>Let’s define the <code class="language-plaintext highlighter-rouge">Communicator</code> trait first independently:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Communicator</span><span class="o">[</span><span class="kt">State</span>, <span class="kt">Input</span>, <span class="kt">Output</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="cm">/** This is the initial actor state */</span>
  <span class="k">def</span> <span class="nf">initial</span><span class="k">:</span> <span class="kt">State</span>

  <span class="cm">/** The state transition function */</span>
  <span class="k">def</span> <span class="nf">process</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">input</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Output</span><span class="o">]</span>, <span class="kt">State</span><span class="o">)]</span>

  <span class="cm">/** The output processing function */</span>
  <span class="k">def</span> <span class="nf">handle</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Output</span><span class="o">,</span> <span class="n">origin</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">initial</code> is simply the initial state machine state, <code class="language-plaintext highlighter-rouge">process</code> is the state transition function and
<code class="language-plaintext highlighter-rouge">handle</code> is the function that will deal with dispatching the result of <code class="language-plaintext highlighter-rouge">process</code>. Because we’re
producing content in another thread, we want to make sure the reference of <code class="language-plaintext highlighter-rouge">sender</code> is fixed, and by
using this with the <code class="language-plaintext highlighter-rouge">pipeTo</code> pattern, we get thread safety. Let’s extend the <code class="language-plaintext highlighter-rouge">Actor</code> trait to get
<code class="language-plaintext highlighter-rouge">receive</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Communicator</span><span class="o">[</span><span class="kt">State</span>, <span class="kt">Input</span>, <span class="kt">Output</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="cm">/** This is the initial actor state */</span>
  <span class="k">def</span> <span class="nf">initial</span><span class="k">:</span> <span class="kt">State</span>

  <span class="cm">/** The state transition function */</span>
  <span class="k">def</span> <span class="nf">handle</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">product</span><span class="k">:</span> <span class="kt">Output</span><span class="o">,</span> <span class="n">origin</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>

  <span class="cm">/** The output processing function */</span>
  <span class="k">def</span> <span class="nf">process</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">input</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Output</span><span class="o">]</span>, <span class="kt">State</span><span class="o">)]</span>
  
  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="nf">active</span><span class="o">(</span><span class="n">initial</span><span class="o">)</span>
  
  <span class="cm">/** I/O handling which the deriving class must implement */</span>
  <span class="k">def</span> <span class="nf">active</span><span class="o">(</span><span class="n">newState</span><span class="k">:</span> <span class="kt">State</span><span class="o">)</span><span class="k">:</span> <span class="kt">Receive</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">active</code> function is the actual output-producing function. The user is left to define three
things:</p>

<ul>
  <li>the initial actor state in <code class="language-plaintext highlighter-rouge">initial</code>
</li>
  <li>the output dispatch function <code class="language-plaintext highlighter-rouge">handle</code>
</li>
  <li>the state transition function <code class="language-plaintext highlighter-rouge">process</code>
</li>
  <li>the <code class="language-plaintext highlighter-rouge">active</code> function which handles input and output</li>
</ul>

<p>To see this in action, first, let’s define the application states.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Library</span> <span class="o">{</span>
  <span class="c1">// Library state</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">LibraryState</span><span class="o">(</span><span class="n">open</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span>

  <span class="c1">// Input alphabet</span>
  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">LibraryInput</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">SetOpen</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>                  <span class="k">extends</span> <span class="nc">Input</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Input</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">GetBook</span><span class="o">(</span><span class="n">isbn</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>                <span class="k">extends</span> <span class="nc">Input</span>

  <span class="c1">// Output alphabet</span>
  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">LibraryOutput</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">SorryWeAreClosed</span>                        <span class="k">extends</span> <span class="nc">Output</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">DoNotHaveIt</span>                             <span class="k">extends</span> <span class="nc">Output</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">SorryReserved</span>                           <span class="k">extends</span> <span class="nc">Output</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Book</span><span class="o">(</span><span class="n">isbn</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>        <span class="k">extends</span> <span class="nc">Output</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Reservation</span><span class="o">(</span><span class="n">isbn</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Output</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The actual state is just a case class: this gives us the nice <code class="language-plaintext highlighter-rouge">copy</code> function for easy updates. Then
we use polymorphism to implement the input and output alphabets. Then we implement the actor itself:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span><span class="o">(</span><span class="n">getReservation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span>
    <span class="k">extends</span> <span class="nc">Communicator</span><span class="o">[</span><span class="kt">LibraryState</span>, <span class="kt">LibraryInput</span>, <span class="kt">LibraryOutput</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">Library._</span>

  <span class="k">def</span> <span class="nf">initial</span> <span class="k">=</span> <span class="nc">State</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="nv">scala</span><span class="o">.</span><span class="py">collection</span><span class="o">.</span><span class="py">immutable</span><span class="o">.</span><span class="py">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">active</span><span class="o">(</span><span class="n">newState</span><span class="k">:</span> <span class="kt">LibraryState</span><span class="o">)</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">case</span> <span class="o">(</span><span class="n">output</span><span class="k">:</span> <span class="kt">LibraryOutput</span><span class="o">,</span> <span class="n">origin</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">handle</span><span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="n">origin</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">input</span><span class="k">:</span> <span class="kt">LibraryInput</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">origin</span> <span class="k">=</span> <span class="nf">sender</span><span class="o">()</span>
      <span class="nf">process</span><span class="o">(</span><span class="n">newState</span><span class="o">,</span> <span class="n">input</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span>
        <span class="nf">case</span> <span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="n">state</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">output</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">o</span> <span class="k">=&gt;</span>
            <span class="n">self</span> <span class="o">!</span> <span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">origin</span><span class="o">)</span>
          <span class="o">}</span>
          <span class="n">self</span> <span class="o">!</span> <span class="n">state</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">process</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">input</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Output</span><span class="o">]</span>, <span class="kt">State</span><span class="o">)]</span> <span class="k">=</span>
    <span class="n">input</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SetOpen</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">Future</span><span class="o">.</span><span class="py">successful</span><span class="o">((</span><span class="nc">None</span><span class="o">,</span> <span class="nv">state</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">open</span> <span class="k">=</span> <span class="n">o</span><span class="o">)))</span>

      <span class="nf">case</span> <span class="o">(</span><span class="nc">GetBook</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">|</span> <span class="nc">AddBook</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">if</span> <span class="o">!</span><span class="nv">state</span><span class="o">.</span><span class="py">open</span> <span class="k">=&gt;</span>
        <span class="nv">Future</span><span class="o">.</span><span class="py">successful</span><span class="o">((</span><span class="nc">Some</span><span class="o">(</span><span class="nc">SorryWeAreClosed</span><span class="o">),</span> <span class="n">state</span><span class="o">))</span>

      <span class="k">case</span> <span class="nc">GetBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">book</span> <span class="k">=</span>
          <span class="k">for</span> <span class="o">{</span>
            <span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nv">state</span><span class="o">.</span><span class="py">books</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span>
          <span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
            <span class="nf">getReservation</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="n">reserved</span> <span class="k">=&gt;</span>
              <span class="nf">if</span> <span class="o">(!</span><span class="n">reserved</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="nc">Book</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)),</span> <span class="nv">state</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">books</span> <span class="k">=</span> <span class="nv">state</span><span class="o">.</span><span class="py">books</span> <span class="o">-</span> <span class="n">isbn</span><span class="o">))</span>
              <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="nc">SorryReserved</span><span class="o">),</span> <span class="n">state</span><span class="o">)</span>
              <span class="o">}</span>
            <span class="o">}</span>
          <span class="o">}</span>

        <span class="n">book</span> <span class="n">getOrElse</span> <span class="nv">Future</span><span class="o">.</span><span class="py">successful</span><span class="o">((</span><span class="nc">Some</span><span class="o">(</span><span class="nc">DoNotHaveIt</span><span class="o">),</span> <span class="n">state</span><span class="o">))</span>
      <span class="o">}</span>

      <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nv">Future</span><span class="o">.</span><span class="py">successful</span><span class="o">((</span><span class="nc">None</span><span class="o">,</span> <span class="nv">state</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">books</span> <span class="k">=</span> <span class="nv">state</span><span class="o">.</span><span class="py">books</span> <span class="o">+</span> <span class="o">(</span><span class="n">isbn</span> <span class="o">-&gt;</span> <span class="n">title</span><span class="o">))))</span>
    <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">handle</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Output</span><span class="o">,</span> <span class="n">origin</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nc">Future</span> <span class="o">{</span>
      <span class="n">origin</span> <span class="o">!</span> <span class="n">output</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="decoupling-akka">Decoupling Akka</h2>

<p>So, now we’ve made a very thin actor, with little I/O logic inside it, but it’s still an
actor. Let’s decouple it entirely from actor semantics. First, we define a <code class="language-plaintext highlighter-rouge">StateMachine[I, O]</code>
trait:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">StateMachine</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">O</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">process</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">I</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">O</span><span class="o">]</span>, <span class="kt">StateMachine</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">O</span><span class="o">])]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And excise the state logic from the Communicator, moving it to the <code class="language-plaintext highlighter-rouge">State</code> case class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">LibraryState</span><span class="o">(</span><span class="n">open</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">],</span> <span class="n">getReservation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])(</span>
    <span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">StateMachine</span><span class="o">[</span><span class="kt">LibraryInput</span>, <span class="kt">LibraryOutput</span><span class="o">]</span> <span class="o">{</span>
    
  <span class="k">def</span> <span class="nf">process</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">LibraryInput</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">LibraryOutput</span><span class="o">]</span>, <span class="kt">LibraryState</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">input</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SetOpen</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">Future</span><span class="o">.</span><span class="py">successful</span><span class="o">((</span><span class="nc">None</span><span class="o">,</span> <span class="nf">copy</span><span class="o">(</span><span class="n">open</span> <span class="k">=</span> <span class="n">o</span><span class="o">)))</span>

      <span class="nf">case</span> <span class="o">(</span><span class="nc">GetBook</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">|</span> <span class="nc">AddBook</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">if</span> <span class="o">!</span><span class="n">open</span> <span class="k">=&gt;</span>
        <span class="nv">Future</span><span class="o">.</span><span class="py">successful</span><span class="o">((</span><span class="nc">Some</span><span class="o">(</span><span class="nc">SorryWeAreClosed</span><span class="o">),</span> <span class="nf">copy</span><span class="o">()))</span>

      <span class="k">case</span> <span class="nc">GetBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">book</span> <span class="k">=</span>
          <span class="k">for</span> <span class="o">{</span>
            <span class="n">title</span> <span class="k">&lt;-</span> <span class="nv">books</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span>
          <span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
            <span class="nf">getReservation</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="n">reserved</span> <span class="k">=&gt;</span>
              <span class="nf">if</span> <span class="o">(!</span><span class="n">reserved</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="nc">Book</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)),</span> <span class="nf">copy</span><span class="o">(</span><span class="n">books</span> <span class="k">=</span> <span class="n">books</span> <span class="o">-</span> <span class="n">isbn</span><span class="o">))</span>
              <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="nc">SorryReserved</span><span class="o">),</span> <span class="nf">copy</span><span class="o">())</span>
              <span class="o">}</span>
            <span class="o">}</span>
          <span class="o">}</span>

        <span class="n">book</span> <span class="n">getOrElse</span> <span class="nv">Future</span><span class="o">.</span><span class="py">successful</span><span class="o">((</span><span class="nc">Some</span><span class="o">(</span><span class="nc">DoNotHaveIt</span><span class="o">),</span> <span class="nf">copy</span><span class="o">()))</span>
      <span class="o">}</span>

      <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nv">Future</span><span class="o">.</span><span class="py">successful</span><span class="o">((</span><span class="nc">None</span><span class="o">,</span> <span class="nf">copy</span><span class="o">(</span><span class="n">books</span> <span class="k">=</span> <span class="n">books</span> <span class="o">+</span> <span class="o">(</span><span class="n">isbn</span> <span class="o">-&gt;</span> <span class="n">title</span><span class="o">))))</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>You may be wondering: wait, where’s the <code class="language-plaintext highlighter-rouge">handle</code> implementation? We kept that out from the state
machine class since it’s not its responsibility - so we keep that in the Communicator:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span><span class="o">(</span><span class="n">getReservation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span>
    <span class="k">extends</span> <span class="nc">Communicator</span><span class="o">[</span><span class="kt">LibraryInput</span>, <span class="kt">LibraryOutput</span>, <span class="kt">LibraryState</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">context.dispatcher</span>

  <span class="k">def</span> <span class="nf">initial</span> <span class="k">=</span> <span class="nc">LibraryState</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="nv">scala</span><span class="o">.</span><span class="py">collection</span><span class="o">.</span><span class="py">immutable</span><span class="o">.</span><span class="py">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span> <span class="n">getReservation</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">handle</span><span class="o">(</span><span class="n">output</span><span class="k">:</span> <span class="kt">LibraryOutput</span><span class="o">,</span> <span class="n">origin</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">origin</span> <span class="o">!</span> <span class="n">output</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">active</span><span class="o">(</span><span class="n">newState</span><span class="k">:</span> <span class="kt">LibraryState</span><span class="o">)</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">case</span> <span class="o">(</span><span class="n">output</span><span class="k">:</span> <span class="kt">LibraryOutput</span><span class="o">,</span> <span class="n">origin</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">handle</span><span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="n">origin</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">state</span><span class="k">:</span> <span class="kt">LibraryState</span> <span class="o">=&gt;</span> <span class="n">context</span> <span class="n">become</span> <span class="nf">active</span><span class="o">(</span><span class="n">state</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">input</span><span class="k">:</span> <span class="kt">LibraryInput</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">origin</span> <span class="k">=</span> <span class="nf">sender</span><span class="o">()</span>
      <span class="nv">newState</span><span class="o">.</span><span class="py">process</span><span class="o">(</span><span class="n">input</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span>
        <span class="nf">case</span> <span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="n">state</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
          <span class="n">output</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">o</span> <span class="k">=&gt;</span> 
            <span class="n">self</span> <span class="o">!</span> <span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">origin</span><span class="o">)</span>
          <span class="o">}</span>
          <span class="n">self</span> <span class="o">!</span> <span class="n">state</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>So, all state is kept neatly in a separate entity that’s entirely unit testable in its own right
without having to rely on Akka testkit or the like – input and output dispatch and state
transitions are done in the <code class="language-plaintext highlighter-rouge">active</code> method.</p>

<p>I know the state case class manipulation introduces more boilerplate, but as long as that
boilerplate isn’t complicated, I think this is a fair compromise. Plus, one can
use <a href="https://github.com/julien-truffaut/Monocle">lenses</a> to remove some of the boilerplate, e.g., 
by defining handy update functions. One could cook up something doggedly interesting using <a href="http://typelevel.org/cats">Cats</a> and
<code class="language-plaintext highlighter-rouge">StateT</code> - as long as you provide a function of the kind <code class="language-plaintext highlighter-rouge">(I, S) =&gt; (Option[O], S)</code>, the sky is the limit.</p>

<p><em>Thanks to Jaakko Pallari (<a href="https://github.com/jkpl" class="user-mention">@jkpl</a>) for previewing this.</em></p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>This is actually false, as Aaron Turon, a core Rust developer, proves in his article about <a href="demonstrates">getting lock-free structures without garbage collection</a>. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

  </div>
  <small style="display: flex; justify-content: space-between;">
    
      <em>
        Previous: <a href="/2016/03/25/focus.html">Focus</a>
      </em>
    

    
      <em>
        Next: <a href="/2016/10/25/web-development-has-become-weird.html">Web development has become weird</a>
      </em>
    
  </small>
</article>

      </div>

      <footer>
        <hr>
        <address>
          
          

          © <a href="mailto:ane@iki.fi">Antoine Kalmbach</a>, see <a href="/this-site/index.html#copying">copying</a>.
          Last updated on <a href="/changelog.html">July 28, 2021</a>. Discuss at my <a href="https://lists.sr.ht/~ane/public-inbox">public inbox</a>.
        </address>
      </footer>
    </div>
    <script src="/assets/hyphenator.js" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [ ['$','$'], ['\\(', '\\)'] ],
         processEscapes: false
       }
     });
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <script src="/assets/hylo.js" type="text/javascript"></script>
    <!-- Google Analytics Tracking code -->
    <script type="text/javascript">

     var _gaq = _gaq || [];
     _gaq.push(['_setAccount', 'UA-58162697-1']);
     _gaq.push(['_trackPageview']);

     (function () {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
     })();

    </script>
  </body>

</html>
