<!-- -*- engine:liquid -*- -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <link href="https://micro.blog/ane" rel="me" />
    <link rel="webmention" href="https://micro.blog/webmention" />

    <title>
      
        Focus
      
    </title>

    
      <meta name="description" content="" />
    
    <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml" />

    <link type="application/atom+xml" rel="alternate" href="http://ane.iki.fi/feed.xml" title="Antoine Kalmbach's website" />
    <meta http-equiv="refresh" content="0; url=http://ane.iki.fi/2016/03/25/focus.html" />
    <link rel="canonical" href="http://ane.iki.fi/2016/03/25/focus.html"/>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Focus | Antoine Kalmbach’s website</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Focus" />
<meta name="author" content="Antoine Kalmbach" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Focus is a design element in programming languages that I think deserves more attention than it gets. A focused language puts emphasis on a set of coherent idioms. Multi-paradigm languages like C++ or C# are unfocused because they lack a certain principle. Take C, for instance. You can do OOP in C, but it’s awkward. You need structures full of function pointers and the language wasn’t designed for it: it’s not a good idea to do it. The point is that you can but you shouldn’t." />
<meta property="og:description" content="Focus is a design element in programming languages that I think deserves more attention than it gets. A focused language puts emphasis on a set of coherent idioms. Multi-paradigm languages like C++ or C# are unfocused because they lack a certain principle. Take C, for instance. You can do OOP in C, but it’s awkward. You need structures full of function pointers and the language wasn’t designed for it: it’s not a good idea to do it. The point is that you can but you shouldn’t." />
<link rel="canonical" href="http://ane.iki.fi/2016/03/25/focus.html" />
<meta property="og:url" content="http://ane.iki.fi/2016/03/25/focus.html" />
<meta property="og:site_name" content="Antoine Kalmbach’s website" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-03-25T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Focus" />
<meta name="twitter:site" content="@anewtf" />
<meta name="twitter:creator" content="@Antoine Kalmbach" />
<script type="application/ld+json">
{"headline":"Focus","dateModified":"2017-04-13T10:11:04+00:00","datePublished":"2016-03-25T00:00:00+00:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://ane.iki.fi/2016/03/25/focus.html"},"url":"http://ane.iki.fi/2016/03/25/focus.html","author":{"@type":"Person","name":"Antoine Kalmbach"},"description":"Focus is a design element in programming languages that I think deserves more attention than it gets. A focused language puts emphasis on a set of coherent idioms. Multi-paradigm languages like C++ or C# are unfocused because they lack a certain principle. Take C, for instance. You can do OOP in C, but it’s awkward. You need structures full of function pointers and the language wasn’t designed for it: it’s not a good idea to do it. The point is that you can but you shouldn’t.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/override.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="/assets/pygments.css" type="text/css" media="screen" />
  </head>
  <body itemscope itemtype="https://schema.org/WebPage" class="home-template">
    <div class="hyphenate">
      <h1 style="text-align: center;">
  Antoine Kalmbach
</h1>
<nav class="navbar">
  <ul>
    <li class="nav-item ">
      <a class="nav-link pl-0" href="/" itemprop="url"><span itemprop="name">Home</span></a>
    </li>
    <li class="nav-item  active">
      <a class="nav-link" href="/archive.html" itemprop="url"><span itemprop="name">Blog</span></a>
    </li>
    <li class="nav-item ">
      <a class="nav-link" href="/about/" itemprop="url"><span itemprop="name">About</span></a>
    </li>
    <li class="nav-item ">
      <a class="nav-link" href="/tags.html" itemprop="url"><span itemprop="name">Index</span></a>
    </li>

    <li class="nav-item mr-n2">
      <a class="nav-link" href="/feed.xml"><i class="fa fa-rss" aria-hidden="true"></i> RSS</a>
    </li>
  </ul>
</nav>

<div class="h-card d-none" style="display: none">
  <img class="u-photo" src="/images/me.png" />
  <a class="u-url" href="http://ane.iki.fi/2016/03/25/focus.html"></a>
  <a class="p-name u-url" href="http://ane.iki.fi">Antoine Kalmbach</a>
  <a class="u-email" href="mailto:">ane@iki.fi</a>
</div>


      <div class="content">
        <article class="h-entry">
  <header>
    





  <h2 class="p-name" style="margin: 0.25rem 0;">
    Focus
  </h2>

  <p class="post-meta text-muted">
    <time class="dt-published" itemprop="datePublished" datetime="2016-03-25 00:00:00 +0000">
      Posted on March 25, 2016

  </p>


    <link itemprop="mainEntityOfPage" itemscope itemtype="http://schema.org/BlogPosting" href="/2016/03/25/focus.html" />
  </header>
  <div class="e-content">
    <p>Focus is a design element in programming languages that I think deserves more attention than it
gets.</p>

<p>A focused language puts emphasis on a set of coherent idioms. Multi-paradigm languages like C++ or
C# are unfocused because they lack a certain principle.</p>

<p>Take C, for instance. You <em>can</em> do OOP in C, but it’s awkward. You need structures full of function
pointers and the language wasn’t designed for it: it’s not a good idea to do it. The point is that
you <em>can</em> but you shouldn’t. 
<!--break--></p>

<p>Focus is not so much of what a language <em>has</em> but something that it <em>embodies</em>. A single-paradigm
language can still be unfocused, because there can be several ways to wield the singular paradigm. A
multi-paradigm language can be focused if the multi-paradigm languages connect at a higher
level. Focus can be implemented as a coding standard or it can be something that everybody
understands as the idiomatic way of doing things.</p>

<p>Focus is not always a positive trait but it rarely is a negative trait. On the other hand, a lack of
focus is more often negative than positive.</p>

<p>Take Haskell, a pure functional language, effectively single-paradigm; it is a very special
case. The language itself is absolutely focused to the point of extreme autism, but its flexible
type system and vibrant community, there are many ways to program Haskell. Do you absolutely need
state? Use state, but be careful. Do you want IO without monads? Well, sure, but be careful.</p>

<p>At a high level, Haskell code is <em>pure</em>. It permits some inconsistencies with its principal paradigm
but it eschews them and this is the key difference.</p>

<p>A bigger problem with focus is that it often is intangible. It’s easier to point out languages that
are unfocused than those that are. Focus is about philosophy. Some language are very
philosophical. For instance, Clojure is just as much about its particular approach to concurrency,
state and identity, that is a language implementing those ideas. The language caught on because
Rich Hickey, the author, did not market it as the tool that would have solved everybody’s problems,
but because he marketed the <em>ideas</em> that Clojure represented as a solution to common programming problems.</p>

<blockquote>
  <p>“If you want to build a ship, don’t drum up the men to gather wood, divide the work and give
orders. Instead, teach them to yearn for the vast and endless sea.”</p>

  <footer class="blockquote-footer">Antoine de Saint-Exupéry</footer>
</blockquote>

<p>In this context, Clojure can be seen as a focused language. These core philosophies are what
constitute the language, the fact that Clojure happens to be a Lisp dialect implementing the
philosophies is secondary in my mind. With that in mind, I acknowledge being a Lisp is also a core
part of Clojure, but its principles about state and identity can be implemented in any
language. Clojure does <em>let</em> you do OOP but it feels awkward. When you grok Clojure you understand
what that means: the language can be bent for that purpose, but it doesn’t want to be. Its
philosophy is like a memory-foam, if you tamper with it, it will coalesce back into its original
form. When you see <em>that</em>, it’s the moment you understand what Clojure—or any other language—is
about.</p>

<p>Some languages double down on philosophy by making it a part of a coding standard and enforcing it:
Go. Go embodies simplicity and intuition, intentionally eschewing things that are not modern, but
complex, opting to keep the core language simple. Some chalk this down as a negative trait, others
love it; I find it to be both good and bad. Good, because I can jump into any Go codebase and get
its purpose in minutes; bad, because sometimes I want to use abstractions for which Go is
unsuitable. I respect its design philosophy, because it has one, and absolutely flaunts it. It’s not
just a structural type system, it’s an <em>idea</em>.</p>

<p>Scala is another beast. It began as an experiment, trying to augment and fix the deficiencies of
Java. It was designed by brilliant PLT theorists and the language is a beautiful and magnanimous
behemoth. Scala has so many features that it eschews focus either intentionally or
unintentionally. On the other hand, Scala is capable of many great things. But if you ask two Scala
programmers what Scala represents to them, you may get different answers.</p>

<p>It can be a technical aspect. To some, it might be about Shapeless or all the cool things that go
with it. Macros. DSLs. Code generation. Or it could be how Akka or Spark are amazing tools.  It
could also be a philosophical difference. Some people want an advanced type system and don’t want to
be constrained by the laziness and purity of Haskell. Others want the JVM. Some just want a better
Java. Some just happen to use it for Spark.</p>

<p>I would choose the simpler Scala, the better Java. Trait-based generics, sum types, implicits, and
functional programming, to name a few. This is not just because it’s less complicated, from a
business perspective, it makes it easier to hire new programmers.</p>

<p>As a professional Scala developer and a long-time functional programming enthusiast, I fear that I
may never comfortably jump to another company, confident that since I’ve written Scala, I can
understand their Scala. That, or years of experience, but who knows what’s enough? Their, whoever
they may be, Scala might not be the simple Scala I and my colleagues prefer.</p>

<p>This is scary. For the future of the language, this is an untenable position. While I absolutely
enjoy working with the language, I’m afraid that it is fated to be like Macbeth from Shakespeare:
“thou shalt get kings, though thou be none”. Thus, Scala will inspire a great language and then
die. Maybe it already did, and the clock is ticking. Some purport Kotlin as the successor, but I
wouldn’t bet on it just yet.</p>

<blockquote>
  <p>“Ah, but a man’s reach should exceed his grasp, or what’s a heaven for?”</p>

  <footer class="blockquote-footer">Robert Browning</footer>
</blockquote>

<p>The thing about Scala is that this is a conscious design decision. The language is <em>meant</em> to have
everything and the kitchen sink. Programming languages don’t have to be simple. Powerful languages
are powerful tools. Use them well, you can achieve greatness. You have to <em>choose</em> your tool set and
hone it.</p>

<p>But for Haskell, Go, and Clojure, you’re using them, and you’re thinking, what is the natural way to
do this? Once you find it, you find yourself implementing ideas using that philosophy, that natural
way, and you’re no longer just using a tool. You’re using an <em>idea</em>.</p>

  </div>
  <small style="display: flex; justify-content: space-between;">
    
      <em>
        Previous: <a href="/2016/03/17/imprecision-and-abstraction.html">Imprecision and abstraction</a>
      </em>
    

    
      <em>
        Next: <a href="/2016/10/14/communicator-functional-actors.html">Communicators: Actors with purely functional state</a>
      </em>
    
  </small>
</article>

      </div>

      <footer>
        <hr>
        <address>
          
          

          &copy; <a href="mailto:ane@iki.fi">Antoine Kalmbach</a>, see <a href="/this-site/index.html#copying">copying</a>.
          Last updated on <a href="/changelog.html">July 28, 2021</a>. Discuss at my <a href="https://lists.sr.ht/~ane/public-inbox">public inbox</a>.
        </address>
      </footer>
    </div>
    <script src="/assets/hyphenator.js" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [ ['$','$'], ['\\(', '\\)'] ],
         processEscapes: false
       }
     });
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <script src="/assets/hylo.js" type="text/javascript"></script>
    <!-- Google Analytics Tracking code -->
    <script type="text/javascript">

     var _gaq = _gaq || [];
     _gaq.push(['_setAccount', 'UA-58162697-1']);
     _gaq.push(['_trackPageview']);

     (function () {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
     })();

    </script>
  </body>

</html>
