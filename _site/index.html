<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

        <title>
            
            Antoine Kalmbach
            
        </title>

        
        <meta name="description" content="The personal blog of Antoine Kalmbach, a Finnish-French software engineer.">
        

        <link type="application/atom+xml" rel="alternate" href="http://ane.github.io/feed.xml" title="Antoine Kalmbach">
        <meta charset="utf-8">
        <meta name="HandheldFriendly" content="True">
        <meta name="MobileOptimized" content="320">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <!-- Begin Jekyll SEO tag v2.0.0 -->
<title>Home - Antoine Kalmbach</title>
<meta property="og:title" content="Home">
<meta name="description" content="Antoine Kalmbach’s Blog">
<meta property="og:description" content="Antoine Kalmbach’s Blog">
<link rel="canonical" href="http://ane.github.io/">
<meta property="og:url" content="http://ane.github.io/">
<meta property="og:site_name" content="Antoine Kalmbach">
<link rel="next" href="http://ane.github.io/page2">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@anewtf">
<meta name="twitter:creator" content="@Antoine Kalmbach">
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Antoine Kalmbach",
    "headline": "Home",
    "description": "Antoine Kalmbach’s Blog",
    "url": "http://ane.github.io/"
  }
</script>
<!-- End Jekyll SEO tag -->
        <link href="https://fonts.googleapis.com/css?family=PT+Serif%7COpen+Sans" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.4/css/bootstrap.min.css" integrity="sha384-2hfp1SzUoho7/TsGGGDaFdsuuDL0LX2hnUp6VkX3CUQ2K4K+xjboZdsXyp4oUHZj" crossorigin="anonymous">
        <link rel="stylesheet" href="/assets/override.css">
        <link rel="stylesheet" href="/assets/pygments.css">

    </head>
    <body class="home-template">
        <div class="hyphenate">
            <header class="main-header">
    <nav id="topnav" class="navbar navbar-full navbar-light bg-faded">
        <div class="container">
            <a class="navbar-brand" href="http://ane.github.io">Antoine Kalmbach</a>
            <button class="navbar-toggler hidden-sm-up" type="button" data-toggle="collapse" data-target="#collapse-navbar">
                ☰
            </button>
            <div class="collapse navbar-toggleable-xs pull-right" id="collapse-navbar">
                <ul class="nav navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="/meta.html">Meta</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/feed.xml">Subscribe</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
</header>


            <div class="container">
                <div class="content">
                    <div>
    
    
    
    
    
    <article class="post">
        
<header>
    <h2 class="page-header">
        <a class="post-title" href="/2016/10/07/actor-meet-communicator.html">Communicators: Actors with purely functional state</a>
    </h2>
    <p>
        <time class="text-muted post-meta" datetime="2016-10-07">
            October 7, 2016
             — Tagged as <a href="/tags/scala">scala</a>, <a href="/tags/akka">akka</a>, <a href="/tags/fp">fp</a>
        </time>
    </p>
</header>

        <p>In Scala, Akka actors, as in the traditional <a href="http://en.wikipedia.org/wiki/Actor_model">Actor model</a>, may
modify private state. The accepted convention is to have a mutable object (e.g. a
<code class="highlighter-rouge">Map</code>), a <code class="highlighter-rouge">var</code>, and mutate it like so:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">books</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span>
  
  <span class="k">def</span> <span class="n">receive</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">books</span> <span class="o">+=</span> <span class="o">(</span><span class="n">isbn</span> <span class="o">-&gt;</span> <span class="n">title</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Library</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div>

<p>This is a <em>bad idea</em>. There are several reasons for this. First, Scala eschews <code class="highlighter-rouge">var</code>s, they should
only be used when absolutely necessary (read: never). Second, the underlying collection needs to be
thread-safe and account for concurrency, which puts strain on the garbage collector, in fact, it
often necessitates the existence of a garbage collector.<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> Lastly, as with any mutable state and
possible lack of referential transparency, the code can become hard to reason about.</p>

<p>Thankfully, Akka actors offer a possibility to do this completely functionally. The function
<code class="highlighter-rouge">context.become</code> allows an Actor to change its <code class="highlighter-rouge">receive</code> method on-the-fly. In other words, it lets
the Actor change its state and communication model. Here’s the above implemented using this
paradigm:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">active</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
  
  <span class="k">def</span> <span class="n">active</span><span class="o">(</span><span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="c1">// for immutable maps, += returns a new collection
</span>      <span class="n">context</span><span class="o">.</span><span class="n">become</span><span class="o">(</span><span class="n">active</span><span class="o">(</span><span class="n">books</span> <span class="o">+=</span> <span class="o">(</span><span class="n">isbn</span> <span class="o">-&gt;</span> <span class="n">title</span><span class="o">)))</span> 
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">active</code> function returns a new <code class="highlighter-rouge">Receive</code>, receiving the current actor <em>state</em> as its
parameter. Adding logic to it is now easy:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">active</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
  
  <span class="k">def</span> <span class="n">active</span><span class="o">(</span><span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">books</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">context</span><span class="o">.</span><span class="n">become</span><span class="o">(</span><span class="n">active</span><span class="o">(</span><span class="n">books</span> <span class="o">+=</span> <span class="o">(</span><span class="n">isbn</span> <span class="o">-&gt;</span> <span class="n">title</span><span class="o">)))</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="s">"Too many books"</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>The above code is now thread-safe and doesn’t use mutable collections, but what if our logic gets
more complicated? What if we need to talk to another Actor, or talk to the sender of the message?
This is where we stumble upon a design feature of Akka: <em>all</em> of its Actors are actually compiled
down into a callback-based implementation. There is no guarantee that a <code class="highlighter-rouge">Future</code> launched in a
receive case will be running in the same thread as the next! One could argue that this is not a
feature but a <em>flaw</em>, but I won’t go that far. Hence, code dealing with Futures in Akka actors needs to deal with the unforgiving reality that there is no
guarantee of thread safety. Case in point:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span><span class="o">(</span><span class="n">popReservation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">active</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
  
  <span class="k">def</span> <span class="n">active</span><span class="o">(</span><span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// as before
</span>    <span class="k">case</span> <span class="nc">AskForBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="n">popReservation</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
        <span class="c1">// AAH!!!
</span>        <span class="n">context</span><span class="o">.</span><span class="n">become</span><span class="o">(</span><span class="n">active</span><span class="o">(</span><span class="n">books</span> <span class="o">-</span> <span class="n">i</span><span class="o">))</span>
        <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">s</span><span class="s">"Here you go: $i"</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre>
</div>

<p>Why am I screaming in the comments? First, as calling <code class="highlighter-rouge">map</code> for our Future launches a new thread, we
have no idea whether <code class="highlighter-rouge">sender()</code> returns the same value in the new thread, and second, we may be
modifying the books collection concurrently with other threads - leaving the garbage collector to
collect our mess. So we strain the GC <em>and</em> risk giving the book to the wrong caller!</p>

<p>Since the actual execution of a Future is left to the execution context, which in the case of Actors
is the <code class="highlighter-rouge">ActorSystem</code>s dispatcher, we may or may not be invoking <code class="highlighter-rouge">sender()</code> in the right thread
— there is simply no guarantee. We can’t reason about it, it has been hidden from us.</p>

<p>To deal with this, Akka has introduced the <code class="highlighter-rouge">pipe</code> pattern, which is an implicit given to Futures
which solves this:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span><span class="o">(</span><span class="n">popReservation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">active</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
  
  <span class="k">def</span> <span class="n">active</span><span class="o">(</span><span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// as before
</span>    <span class="k">case</span> <span class="nc">AskForBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="c1">// launch another thread
</span>      <span class="k">val</span> <span class="n">reservation</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">popReservation</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
        <span class="n">s</span><span class="s">"Here you go: $i"</span>
        <span class="n">context</span><span class="o">.</span><span class="n">become</span><span class="o">(</span><span class="n">active</span><span class="o">(</span><span class="n">books</span> <span class="o">-</span> <span class="n">isbn</span><span class="o">))</span> <span class="c1">// AAH!
</span>      <span class="o">}</span>
      <span class="c1">// but sender() is still the same
</span>      <span class="n">reservation</span> <span class="n">pipeTo</span> <span class="n">sender</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Another option is to fix the reference of <code class="highlighter-rouge">sender</code>:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">sender</span><span class="o">()</span>
<span class="k">val</span> <span class="n">reservation</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">popReservation</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
  <span class="n">s</span> <span class="o">!</span> <span class="n">s</span><span class="s">"Here you go: $i"</span>
  <span class="n">context</span><span class="o">.</span><span class="n">become</span><span class="o">(</span><span class="n">active</span><span class="o">(</span><span class="n">books</span> <span class="o">-</span> <span class="n">isbn</span><span class="o">))</span> <span class="c1">// AAH!
</span><span class="o">}</span>
</code></pre>
</div>

<p>Ok, now we’ve fixed <code class="highlighter-rouge">sender()</code>, but what about the <code class="highlighter-rouge">books</code> collection? Let’s add a <code class="highlighter-rouge">PopBook(isbn:
String)</code> case class, and handle that for removals:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span><span class="o">(</span><span class="n">popReservation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">active</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
  
  <span class="k">def</span> <span class="n">active</span><span class="o">(</span><span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// as before
</span>    <span class="k">case</span> <span class="nc">PopBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">context</span><span class="o">.</span><span class="n">become</span><span class="o">(</span><span class="n">active</span><span class="o">(</span><span class="n">books</span> <span class="o">-</span> <span class="n">isbn</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">AskForBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="c1">// launch another thread
</span>      <span class="k">val</span> <span class="n">reservation</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">popReservation</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
        <span class="n">s</span><span class="s">"Here you go: $i"</span>
        <span class="n">self</span> <span class="o">!</span> <span class="nc">PopBook</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
      <span class="o">}</span>
      <span class="c1">// but sender() is still the same
</span>      <span class="n">reservation</span> <span class="n">pipeTo</span> <span class="n">sender</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Sending messages to <code class="highlighter-rouge">self</code> is always thread-safe - the reference does not change over time. So, at
this point, it seems clear that making actor code thread-<em>sane</em> involves the use of:</p>

<ul>
  <li>immutable state - call <code class="highlighter-rouge">context.become</code> with a closure over the new actor state,</li>
  <li>converting asynchronous state modifications as messages to be handled later, and</li>
  <li>making sure the <code class="highlighter-rouge">sender()</code> reference is consistent</li>
</ul>

<p>What about complicated states? What if we need to react differently to these messages, e.g., when
the library is closed? I sense that you’re about to mention Akka’s <code class="highlighter-rouge">FSM</code> construct, which
builds a state machine, encapsulating state and transitions to what is essentially syntactic sugar,
and on the surface, seems like a good idea.</p>

<h2 id="enter-akka-fsms">Enter Akka FSMs</h2>

<p>At a closer look, it essentially leads us to repeat the same mistakes as above, and the arguments
against it are argumented <a href="https://github.com/alexandru/scala-best-practices/blob/master/sections/5-actors.md#55-should-not-use-akka-fsm" target="_blank">here</a>. In
summary, it boils down to:</p>

<ol>
  <li>Akka FSM’s is too restrictive. You cannot handle multi-step or complicated state transitions, and
modeling undeterministic behaviour is impossible.</li>
  <li>You are tied to Akka completely, you must use Akka testkit for your tests. Anyone who has worked
with testkit knows this to be a burden.</li>
  <li>State transitions have identity instead of being truly functional, that is, FSMs alter the
<em>current</em> state instead of <em>producing</em> a new one.</li>
</ol>

<p>Moreover, and I think this is the biggest shortcoming, the Akka FSM are finite-state <em>automata</em>
— they are characterised by the state transition function <code class="highlighter-rouge">(Input, State) =&gt; State</code>. Since we
know actors are more about communication than anything else, this model is insufficient, and what we
need is a state machine that can produce <em>output</em>: a finite state <em>transducer</em>. Its state transition
function has the signature <code class="highlighter-rouge">(Input, State) =&gt; (Output, State)</code> - every transition produces an
output, and Scala can model this efficiently:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">trait</span> <span class="nc">FSA</span><span class="o">[</span><span class="kt">State</span>, <span class="kt">Input</span>, <span class="kt">Output</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">transition</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Output</span><span class="o">],</span> <span class="nc">State</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div>

<p>With all these flaws, despite being a nice idea at a glance, it’s obvious that for any complicated
logic Akka FSM’s aren’t sufficient.</p>

<p>Let’s envision a radical version of actors, accounting for all the flaws described above:</p>

<ul>
  <li>State transitions should be about producing a new state, i.e. <code class="highlighter-rouge">(Input, State) =&gt; (Output, State)</code>
</li>
  <li>Actor computations will deal with asynchronous code, we must deal with this intelligently</li>
  <li>Keep I/O logic out of actors - the actor only communicates with the external world</li>
</ul>

<p>Putting emphasis on the last point, I’ve come up with a moniker called <em>communicators</em>.</p>

<h2 id="actor-meet-communicator">Actor, meet communicator</h2>

<p>Let’s define the <code class="highlighter-rouge">Communicator</code> trait first independently:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">trait</span> <span class="nc">Communicator</span><span class="o">[</span><span class="kt">State</span>, <span class="kt">Input</span>, <span class="kt">Output</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="cm">/** This is the initial actor state */</span>
  <span class="k">def</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">State</span>

  <span class="cm">/** The state transition function */</span>
  <span class="k">def</span> <span class="n">process</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">input</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Output</span><span class="o">]</span>, <span class="kt">State</span><span class="o">)]</span>

  <span class="cm">/** The output processing function */</span>
  <span class="k">def</span> <span class="n">handle</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Output</span><span class="o">,</span> <span class="n">origin</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">initial</code> is simply the initial state machine state, <code class="highlighter-rouge">process</code> is the state transition function and
<code class="highlighter-rouge">handle</code> is the function that will deal with dispatching the result of <code class="highlighter-rouge">process</code>. Because we’re
producing content in another thread, we want to make sure the reference of <code class="highlighter-rouge">sender</code> is fixed, and by
using this with the <code class="highlighter-rouge">pipeTo</code> pattern, we get thread safety. Let’s extend the <code class="highlighter-rouge">Actor</code> trait to get
<code class="highlighter-rouge">receive</code></p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">trait</span> <span class="nc">Communicator</span><span class="o">[</span><span class="kt">State</span>, <span class="kt">Input</span>, <span class="kt">Output</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="cm">/** This is the initial actor state */</span>
  <span class="k">def</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">State</span>

  <span class="cm">/** The state transition function */</span>
  <span class="k">def</span> <span class="n">handle</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">product</span><span class="k">:</span> <span class="kt">Output</span><span class="o">,</span> <span class="n">origin</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>

  <span class="cm">/** The output processing function */</span>
  <span class="k">def</span> <span class="n">process</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">input</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Output</span><span class="o">]</span>, <span class="kt">State</span><span class="o">)]</span>
  
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">active</span><span class="o">(</span><span class="n">initial</span><span class="o">)</span>
  
  <span class="cm">/** I/O handling which the deriving class must implement */</span>
  <span class="k">def</span> <span class="n">active</span><span class="o">(</span><span class="n">newState</span><span class="k">:</span> <span class="kt">State</span><span class="o">)</span><span class="k">:</span> <span class="kt">Receive</span>
<span class="o">}</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">active</code> function is the actual output-producing function. The user is left to define three
things:</p>

<ul>
  <li>the initial actor state in <code class="highlighter-rouge">initial</code>
</li>
  <li>the output dispatch function <code class="highlighter-rouge">handle</code>
</li>
  <li>the state transition function <code class="highlighter-rouge">process</code>
</li>
  <li>the <code class="highlighter-rouge">active</code> function which handles input and output</li>
</ul>

<p>To see this in action, first, let’s define the application states.</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">object</span> <span class="nc">Library</span> <span class="o">{</span>
  <span class="c1">// Library state
</span>  <span class="k">case</span> <span class="k">class</span> <span class="nc">LibraryState</span><span class="o">(</span><span class="n">open</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span>

  <span class="c1">// Input alphabet
</span>  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">LibraryInput</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">SetOpen</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>                  <span class="k">extends</span> <span class="nc">Input</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Input</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">GetBook</span><span class="o">(</span><span class="n">isbn</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>                <span class="k">extends</span> <span class="nc">Input</span>

  <span class="c1">// Output alphabet
</span>  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">LibraryOutput</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">SorryWeAreClosed</span>                        <span class="k">extends</span> <span class="nc">Output</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">DoNotHaveIt</span>                             <span class="k">extends</span> <span class="nc">Output</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">SorryReserved</span>                           <span class="k">extends</span> <span class="nc">Output</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Book</span><span class="o">(</span><span class="n">isbn</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>        <span class="k">extends</span> <span class="nc">Output</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Reservation</span><span class="o">(</span><span class="n">isbn</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Output</span>
<span class="o">}</span>
</code></pre>
</div>

<p>The actual state is just a case class: this gives us the nice <code class="highlighter-rouge">copy</code> function for easy updates. Then
we use polymorphism to implement the input and output alphabets. Then we implement the actor itself:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span><span class="o">(</span><span class="n">getReservation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span>
    <span class="k">extends</span> <span class="nc">Communicator</span><span class="o">[</span><span class="kt">LibraryState</span>, <span class="kt">LibraryInput</span>, <span class="kt">LibraryOutput</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">Library._</span>

  <span class="k">def</span> <span class="n">initial</span> <span class="k">=</span> <span class="nc">State</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">active</span><span class="o">(</span><span class="n">newState</span><span class="k">:</span> <span class="kt">LibraryState</span><span class="o">)</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">output</span><span class="k">:</span> <span class="kt">LibraryOutput</span><span class="o">,</span> <span class="n">origin</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">handle</span><span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="n">origin</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">input</span><span class="k">:</span> <span class="kt">LibraryInput</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">origin</span> <span class="k">=</span> <span class="n">sender</span><span class="o">()</span>
      <span class="n">process</span><span class="o">(</span><span class="n">newState</span><span class="o">,</span> <span class="n">input</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span>
        <span class="k">case</span> <span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="n">state</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">output</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">o</span> <span class="k">=&gt;</span>
            <span class="n">self</span> <span class="o">!</span> <span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">origin</span><span class="o">)</span>
          <span class="o">}</span>
          <span class="n">self</span> <span class="o">!</span> <span class="n">state</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">process</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">input</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Output</span><span class="o">]</span>, <span class="kt">State</span><span class="o">)]</span> <span class="k">=</span>
    <span class="n">input</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SetOpen</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">((</span><span class="nc">None</span><span class="o">,</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">open</span> <span class="k">=</span> <span class="n">o</span><span class="o">)))</span>

      <span class="k">case</span> <span class="o">(</span><span class="nc">GetBook</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">|</span> <span class="nc">AddBook</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">if</span> <span class="o">!</span><span class="n">state</span><span class="o">.</span><span class="n">open</span> <span class="k">=&gt;</span>
        <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">((</span><span class="nc">Some</span><span class="o">(</span><span class="nc">SorryWeAreClosed</span><span class="o">),</span> <span class="n">state</span><span class="o">))</span>

      <span class="k">case</span> <span class="nc">GetBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">book</span> <span class="k">=</span>
          <span class="k">for</span> <span class="o">{</span>
            <span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">state</span><span class="o">.</span><span class="n">books</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span>
          <span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
            <span class="n">getReservation</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="n">reserved</span> <span class="k">=&gt;</span>
              <span class="k">if</span> <span class="o">(!</span><span class="n">reserved</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="nc">Book</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)),</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">books</span> <span class="k">=</span> <span class="n">state</span><span class="o">.</span><span class="n">books</span> <span class="o">-</span> <span class="n">isbn</span><span class="o">))</span>
              <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="nc">SorryReserved</span><span class="o">),</span> <span class="n">state</span><span class="o">)</span>
              <span class="o">}</span>
            <span class="o">}</span>
          <span class="o">}</span>

        <span class="n">book</span> <span class="n">getOrElse</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">((</span><span class="nc">Some</span><span class="o">(</span><span class="nc">DoNotHaveIt</span><span class="o">),</span> <span class="n">state</span><span class="o">))</span>
      <span class="o">}</span>

      <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">((</span><span class="nc">None</span><span class="o">,</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">books</span> <span class="k">=</span> <span class="n">state</span><span class="o">.</span><span class="n">books</span> <span class="o">+</span> <span class="o">(</span><span class="n">isbn</span> <span class="o">-&gt;</span> <span class="n">title</span><span class="o">))))</span>
    <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">handle</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Output</span><span class="o">,</span> <span class="n">origin</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nc">Future</span> <span class="o">{</span>
      <span class="n">origin</span> <span class="o">!</span> <span class="n">output</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="decoupling-akka">Decoupling Akka</h2>

<p>So, now we’ve made a very thin actor, with little I/O logic inside it, but it’s still an
actor. Let’s decouple it entirely from actor semantics. First, we define a <code class="highlighter-rouge">StateMachine[I, O]</code>
trait:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">trait</span> <span class="nc">StateMachine</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">O</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">process</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">I</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">O</span><span class="o">]</span>, <span class="kt">StateMachine</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">O</span><span class="o">])]</span>
<span class="o">}</span>
</code></pre>
</div>

<p>And excise the state logic from the Communicator, moving it to the <code class="highlighter-rouge">State</code> case class:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">LibraryState</span><span class="o">(</span><span class="n">open</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">books</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">],</span> <span class="n">getReservation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])(</span>
    <span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">StateMachine</span><span class="o">[</span><span class="kt">LibraryInput</span>, <span class="kt">LibraryOutput</span><span class="o">]</span> <span class="o">{</span>
    
  <span class="k">def</span> <span class="n">process</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">LibraryInput</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">LibraryOutput</span><span class="o">]</span>, <span class="kt">LibraryState</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">input</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SetOpen</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">((</span><span class="nc">None</span><span class="o">,</span> <span class="n">copy</span><span class="o">(</span><span class="n">open</span> <span class="k">=</span> <span class="n">o</span><span class="o">)))</span>

      <span class="k">case</span> <span class="o">(</span><span class="nc">GetBook</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">|</span> <span class="nc">AddBook</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">if</span> <span class="o">!</span><span class="n">open</span> <span class="k">=&gt;</span>
        <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">((</span><span class="nc">Some</span><span class="o">(</span><span class="nc">SorryWeAreClosed</span><span class="o">),</span> <span class="n">copy</span><span class="o">()))</span>

      <span class="k">case</span> <span class="nc">GetBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">book</span> <span class="k">=</span>
          <span class="k">for</span> <span class="o">{</span>
            <span class="n">title</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span>
          <span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
            <span class="n">getReservation</span><span class="o">(</span><span class="n">isbn</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="n">reserved</span> <span class="k">=&gt;</span>
              <span class="k">if</span> <span class="o">(!</span><span class="n">reserved</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="nc">Book</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)),</span> <span class="n">copy</span><span class="o">(</span><span class="n">books</span> <span class="k">=</span> <span class="n">books</span> <span class="o">-</span> <span class="n">isbn</span><span class="o">))</span>
              <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="nc">SorryReserved</span><span class="o">),</span> <span class="n">copy</span><span class="o">())</span>
              <span class="o">}</span>
            <span class="o">}</span>
          <span class="o">}</span>

        <span class="n">book</span> <span class="n">getOrElse</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">((</span><span class="nc">Some</span><span class="o">(</span><span class="nc">DoNotHaveIt</span><span class="o">),</span> <span class="n">copy</span><span class="o">()))</span>
      <span class="o">}</span>

      <span class="k">case</span> <span class="nc">AddBook</span><span class="o">(</span><span class="n">isbn</span><span class="o">,</span> <span class="n">title</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">((</span><span class="nc">None</span><span class="o">,</span> <span class="n">copy</span><span class="o">(</span><span class="n">books</span> <span class="k">=</span> <span class="n">books</span> <span class="o">+</span> <span class="o">(</span><span class="n">isbn</span> <span class="o">-&gt;</span> <span class="n">title</span><span class="o">))))</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>You may be wondering: wait, where’s the <code class="highlighter-rouge">handle</code> implementation? We kept that out from the state
machine class since it’s not its responsibility - so we keep that in the Communicator:</p>

<div class="language-scala highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span><span class="o">(</span><span class="n">getReservation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span>
    <span class="k">extends</span> <span class="nc">Communicator</span><span class="o">[</span><span class="kt">LibraryInput</span>, <span class="kt">LibraryOutput</span>, <span class="kt">LibraryState</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">context.dispatcher</span>

  <span class="k">def</span> <span class="n">initial</span> <span class="k">=</span> <span class="nc">LibraryState</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">,</span> <span class="n">getReservation</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">handle</span><span class="o">(</span><span class="n">output</span><span class="k">:</span> <span class="kt">LibraryOutput</span><span class="o">,</span> <span class="n">origin</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">origin</span> <span class="o">!</span> <span class="n">output</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">active</span><span class="o">(</span><span class="n">newState</span><span class="k">:</span> <span class="kt">LibraryState</span><span class="o">)</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">output</span><span class="k">:</span> <span class="kt">LibraryOutput</span><span class="o">,</span> <span class="n">origin</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">handle</span><span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="n">origin</span><span class="o">)</span>

    <span class="k">case</span> <span class="n">input</span><span class="k">:</span> <span class="kt">LibraryInput</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">origin</span> <span class="k">=</span> <span class="n">sender</span><span class="o">()</span>
      <span class="n">newState</span><span class="o">.</span><span class="n">process</span><span class="o">(</span><span class="n">input</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span>
        <span class="k">case</span> <span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="n">state</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
          <span class="n">output</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">o</span> <span class="k">=&gt;</span> 
            <span class="n">self</span> <span class="o">!</span> <span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">origin</span><span class="o">)</span>
          <span class="o">}</span>
          <span class="n">self</span> <span class="o">!</span> <span class="n">state</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre>
</div>

<p>So, all state is kept neatly in a separate entity that’s entirely unit testable in its own right
without having to rely on Akka testkit or the like – input and output dispatch and state
transitions are done in the <code class="highlighter-rouge">active</code> method.</p>

<p>I know the state case class manipulation introduces more boilerplate, but as long as that
boilerplate isn’t complicated, I think this is a fair compromise. Plus, one can
use <a href="https://github.com/julien-truffaut/Monocle">lenses</a> to remove some of the boilerplate, e.g., 
by defining handy update functions. One could cook up something doggedly interesting using <a href="http://typelevel.org/cats">Cats</a> and
<code class="highlighter-rouge">StateT</code> - as long as you provide a function of the kind <code class="highlighter-rouge">(I, S) =&gt; (Option[O], S)</code>, the sky is the limit.</p>

<p><em>Thanks to Jaakko Pallari (<a href="https://github.com/jkpl" class="user-mention">@jkpl</a>) for previewing this.</em></p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>This is actually false, as Aaron Turon, a core Rust developer, proves in his article about <a href="demonstrates">getting lock-free structures without garbage collection</a>. <a href="#fnref:1" class="reversefootnote">↩</a></p>
    </li>
  </ol>
</div>

    </article>
    
    
    
    <article class="post">
        
<header>
    <h2 class="page-header">
        <a class="post-title" href="/2016/03/25/focus.html">Focus</a>
    </h2>
    <p>
        <time class="text-muted post-meta" datetime="2016-03-25">
            March 25, 2016
             — Tagged as <a href="/tags/plt">plt</a>, <a href="/tags/go">go</a>, <a href="/tags/scala">scala</a>, <a href="/tags/haskell">haskell</a>, <a href="/tags/clojure">clojure</a>
        </time>
    </p>
</header>

        <p>Focus is a design element in programming languages that I think deserves more attention than it
gets.</p>

<p>A focused language puts emphasis on a set of coherent idioms. Multi-paradigm languages like C++ or
C# are unfocused because they lack a certain principle.</p>

<p>Take C, for instance. You <em>can</em> do OOP in C, but it’s awkward. You need structures full of function
pointers and the language wasn’t designed for it: it’s not a good idea to do it. The point is that
you <em>can</em> but you shouldn’t.</p>

<p>Focus is not so much of what a language <em>has</em> but something that it <em>embodies</em>. A single-paradigm
language can still be unfocused, because there can be several ways to wield the singular paradigm. A
multi-paradigm language can be focused if the multi-paradigm languages connect at a higher
level. Focus can be implemented as a coding standard or it can be something that everybody
understands as the idiomatic way of doing things.</p>

<p>Focus is not always a positive trait but it rarely is a negative trait. On the other hand, a lack of
focus is more often negative than positive.</p>

<p>Take Haskell, a pure functional language, effectively single-paradigm; it is a very special
case. The language itself is absolutely focused to the point of extreme autism, but its flexible
type system and vibrant community, there are many ways to program Haskell. Do you absolutely need
state? Use state, but be careful. Do you want IO without monads? Well, sure, but be careful.</p>

<p>At a high level, Haskell code is <em>pure</em>. It permits some inconsistencies with its principal paradigm
but it eschews them and this is the key difference.</p>

<p>A bigger problem with focus is that it often is intangible. It’s easier to point out languages that
are unfocused than those that are. Focus is about philosophy. Some language are very
philosophical. For instance, Clojure is just as much about its particular approach to concurrency,
state and identity, that is a language implementing those ideas. The language caught on because
Rich Hickey, the author, did not market it as the tool that would have solved everybody’s problems,
but because he marketed the <em>ideas</em> that Clojure represented as a solution to common programming problems.</p>

<blockquote>
  <p>“If you want to build a ship, don’t drum up the men to gather wood, divide the work and give
orders. Instead, teach them to yearn for the vast and endless sea.”</p>

  <footer class="blockquote-footer">Antoine de Saint-Exupéry</footer>
</blockquote>

<p>In this context, Clojure can be seen as a focused language. These core philosophies are what
constitute the language, the fact that Clojure happens to be a Lisp dialect implementing the
philosophies is secondary in my mind. With that in mind, I acknowledge being a Lisp is also a core
part of Clojure, but its principles about state and identity can be implemented in any
language. Clojure does <em>let</em> you do OOP but it feels awkward. When you grok Clojure you understand
what that means: the language can be bent for that purpose, but it doesn’t want to be. Its
philosophy is like a memory-foam, if you tamper with it, it will coalesce back into its original
form. When you see <em>that</em>, it’s the moment you understand what Clojure—or any other language—is
about.</p>

<p>Some languages double down on philosophy by making it a part of a coding standard and enforcing it:
Go. Go embodies simplicity and intuition, intentionally eschewing things that are not modern, but
complex, opting to keep the core language simple. Some chalk this down as a negative trait, others
love it; I find it to be both good and bad. Good, because I can jump into any Go codebase and get
its purpose in minutes; bad, because sometimes I want to use abstractions for which Go is
unsuitable. I respect its design philosophy, because it has one, and absolutely flaunts it. It’s not
just a structural type system, it’s an <em>idea</em>.</p>

<p>Scala is another beast. It began as an experiment, trying to augment and fix the deficiencies of
Java. It was designed by brilliant PLT theorists and the language is a beautiful and magnanimous
behemoth. Scala has so many features that it eschews focus either intentionally or
unintentionally. On the other hand, Scala is capable of many great things. But if you ask two Scala
programmers what Scala represents to them, you may get different answers.</p>

<p>It can be a technical aspect. To some, it might be about Shapeless or all the cool things that go
with it. Macros. DSLs. Code generation. Or it could be how Akka or Spark are amazing tools.  It
could also be a philosophical difference. Some people want an advanced type system and don’t want to
be constrained by the laziness and purity of Haskell. Others want the JVM. Some just want a better
Java. Some just happen to use it for Spark.</p>

<p>I would choose the simpler Scala, the better Java. Trait-based generics, sum types, implicits, and
functional programming, to name a few. This is not just because it’s less complicated, from a
business perspective, it makes it easier to hire new programmers.</p>

<p>As a professional Scala developer and a long-time functional programming enthusiast, I fear that I
may never comfortably jump to another company, confident that since I’ve written Scala, I can
understand their Scala. That, or years of experience, but who knows what’s enough? Their, whoever
they may be, Scala might not be the simple Scala I and my colleagues prefer.</p>

<p>This is scary. For the future of the language, this is an untenable position. While I absolutely
enjoy working with the language, I’m afraid that it is fated to be like Macbeth from Shakespeare:
“thou shalt get kings, though thou be none”. Thus, Scala will inspire a great language and then
die. Maybe it already did, and the clock is ticking. Some purport Kotlin as the successor, but I
wouldn’t bet on it just yet.</p>

<blockquote>
  <p>“Ah, but a man’s reach should exceed his grasp, or what’s a heaven for?”</p>

  <footer class="blockquote-footer">Robert Browning</footer>
</blockquote>

<p>The thing about Scala is that this is a conscious design decision. The language is <em>meant</em> to have
everything and the kitchen sink. Programming languages don’t have to be simple. Powerful languages
are powerful tools. Use them well, you can achieve greatness. You have to <em>choose</em> your tool set and
hone it.</p>

<p>But for Haskell, Go, and Clojure, you’re using them, and you’re thinking, what is the natural way to
do this? Once you find it, you find yourself implementing ideas using that philosophy, that natural
way, and you’re no longer just using a tool. You’re using an <em>idea</em>.</p>

    </article>
    
    


    <nav class="pagination" role="pagination">
    
    <span class="page-number"> Page 1 of 3 </span>
     
        <a class="older-posts" href="/page2/" title="Next Page">Older Posts »</a>
     
</nav>
    
</div>

                </div>
                
                <footer>
                    <hr>
                    <address>
                        Copyright © 2016 <a href="">Antoine Kalmbach</a> under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>.
                    </address>
                </footer>
            </div>
            <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.0.0/jquery.min.js" integrity="sha384-THPy051/pYDQGanwU6poAc/hOdQxjnOEXzbT+OuUAFqNqFjL+4IGLBgCJC3ZOShY" crossorigin="anonymous"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.2.0/js/tether.min.js" integrity="sha384-Plbmg8JY28KFelvJVai01l8WyZzrYWG825m+cZ0eDDS1f7d/js6ikvy1+X+guPIB" crossorigin="anonymous"></script>
            <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.4/js/bootstrap.min.js" integrity="sha384-VjEeINv9OSwtWFLAtmc4JCtEJXXBub00gtSnszmspDLCtC0I4z4nqz7rEFbIZLLU" crossorigin="anonymous"></script>
            <script type="text/javascript" src="/assets/toc.min.js"></script>
            <script src="/assets/hyphenator.js" type="text/javascript"></script>
            <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
            </script>
            <script src="https://use.fontawesome.com/2772baba9e.js"></script>
            <script src="/assets/hylo.js" type="text/javascript"></script>
            <!-- Google Analytics Tracking code -->
            <script type="text/javascript">

             var _gaq = _gaq || [];
             _gaq.push(['_setAccount', 'UA-58162697-1']);
             _gaq.push(['_trackPageview']);

             (function() {
                 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
             })();

            </script>   
        </div>
        
        
    </body>
</html>
