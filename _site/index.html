<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

        <title>
            
            Antoine Kalmbach
            
        </title>

        
        <meta name="description" content="The personal blog of Antoine Kalmbach, a Finnish-French software engineer." />
        

        <link type="application/atom+xml" rel="alternate" href="http://ane.iki.fi/feed.xml" title="Antoine Kalmbach" />
        <meta charset="utf-8">
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta content="" property="og:site_name">
        
        <meta content="Home" property="og:title">
        
        
        <meta content="article" property="og:type">
        
        
        <meta content="" property="og:description">
        
        
        <meta content="http://ane.iki.fi/" property="og:url">
        
        
        
        <meta content="http://ane.iki.fi/assets/images/profile.jpg" property="og:image">
        
        
        

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@ironballs">
        <meta name="twitter:creator" content="@ironballs">
        
        <meta name="twitter:title" content="Home">
        
        
        <meta name="twitter:url" content="http://ane.iki.fi/">
        

        
        <meta name="twitter:description" content="">
        
        
        <meta name="twitter:image:src" content="http://ane.iki.fi/assets/images/profile.jpg">
        

        <link href='https://fonts.googleapis.com/css?family=Gentium+Book+Basic:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">
        <link rel="stylesheet" href="/assets/override.css" />
        <link rel="stylesheet" href="/assets/pygments.css" />

    </head>
    <body class="home-template">
        <div class="hyphenate">
            <header class="main-header">
    <nav id="topnav" class="navbar navbar-full navbar-light bg-faded">
        <div class="container">
            <a class="navbar-brand" href="http://ane.iki.fi">Antoine Kalmbach</a>
            <button class="navbar-toggler hidden-sm-up" type="button" data-toggle="collapse" data-target="#collapse-navbar">
                &#9776;
            </button>
            <div class="collapse navbar-toggleable-xs pull-right" id="collapse-navbar">
                <ul class="nav navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="/meta.html">Meta</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/feed.xml">Subscribe</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
</header>


            <div class="container">
                <div class="content">
                    <div>
    
    
    <article class="post">
        <header>
            <h1>
                <a class="post-title" href="/2016/03/25/focus.html">Focus</a>
            </h1>
            <p>
                <time class="text-muted post-meta" datetime="2016-03-25">
                    March 25, 2016
                    &mdash; Tagged as <a href="/tags/plt">plt</a>, <a href="/tags/go">go</a>, <a href="/tags/scala">scala</a>, <a href="/tags/haskell">haskell</a>, <a href="/tags/clojure">clojure</a> 
                </time>
            </p>
        </header>
        <p>Focus is a design element in programming languages that I think deserves more attention than it
gets.</p>

<p>A focused language puts emphasis on a set of coherent idioms. Multi-paradigm languages like C++ or
C# are unfocused because they lack a certain principle.</p>

<p>Take C, for instance. You <em>can</em> do OOP in C, but it’s awkward. You need structures full of function
pointers and the language wasn’t designed for it: it’s not a good idea to do it. The point is that
you <em>can</em> but you shouldn’t.</p>

<p>Focus is not so much of what a language <em>has</em> but something that it <em>embodies</em>. A single-paradigm
language can still be unfocused, because there can be several ways to wield the singular paradigm. A
multi-paradigm language can be focused if the multi-paradigm languages connect at a higher
level. Focus can be implemented as a coding standard or it can be something that everybody
understands as the idiomatic way of doing things.</p>

<p>Focus is not always a positive trait but it rarely is a negative trait. On the other hand, a lack of
focus is more often negative than positive.</p>

<p>Take Haskell, a pure functional language, effectively single-paradigm; it is a very special
case. The language itself is absolutely focused to the point of extreme autism, but its flexible
type system and vibrant community, there are many ways to program Haskell. Do you absolutely need
state? Use state, but be careful. Do you want IO without monads? Well, sure, but be careful.</p>

<p>At a high level, Haskell code is <em>pure</em>. It permits some inconsistencies with its principal paradigm
but it eschews them and this is the key difference.</p>

<p>A bigger problem with focus is that it often is intangible. It’s easier to point out languages that
are unfocused than those that are. Focus is about philosophy. Some language are very
philosophical. For instance, Clojure is just as much about its particular approach to concurrency,
state and identity, that is a language implementing those ideas. The language caught on because
Rich Hickey, the author, did not market it as the tool that would have solved everybody’s problems,
but because he marketed the <em>ideas</em> that Clojure represented as a solution to common programming problems.</p>

<blockquote>
  <p>“If you want to build a ship, don’t drum up the men to gather wood, divide the work and give
orders. Instead, teach them to yearn for the vast and endless sea.”</p>

  <p>—Antoine de Saint-Exupéry</p>
</blockquote>

<p>In this context, Clojure can be seen as a focused language. These core philosophies are what
constitute the language, the fact that Clojure happens to be a Lisp dialect implementing the
philosophies is secondary in my mind. With that in mind, I acknowledge being a Lisp is also a core
part of Clojure, but its principles about state and identity can be implemented in any
language. Clojure does <em>let</em> you do OOP but it feels awkward. When you grok Clojure you understand
what that means: the language can be bent for that purpose, but it doesn’t want to be. Its
philosophy is like a memory-foam, if you tamper with it, it will coalesce back into its original
form. When you see <em>that</em>, it’s the moment you understand what Clojure—or any other language—is
about.</p>

<p>Some languages double down on philosophy by making it a part of a coding standard and enforcing it:
Go. Go embodies simplicity and intuition, intentionally eschewing things that are not modern, but
complex, opting to keep the core language simple. Some chalk this down as a negative trait, others
love it; I find it to be both good and bad. Good, because I can jump into any Go codebase and get
its purpose in minutes; bad, because sometimes I want to use abstractions for which Go is
unsuitable. I respect its design philosophy, because it has one, and absolutely flaunts it. It’s not
just a structural type system, it’s an <em>idea</em>.</p>

<p>Scala is another beast. It began as an experiment, trying to augment and fix the deficiencies of
Java. It was designed by brilliant PLT theorists and the language is a beautiful and magnanimous
behemoth. Scala has so many features that it eschews focus either intentionally or
unintentionally. On the other hand, Scala is capable of many great things. But if you ask two Scala
programmers what Scala represents to them, you may get different answers.</p>

<p>It can be a technical aspect. To some, it might be about Shapeless or all the cool things that go
with it. Macros. DSLs. Code generation. Or it could be how Akka or Spark are amazing tools.  It
could also be a philosophical difference. Some people want an advanced type system and don’t want to
be constrained by the laziness and purity of Haskell. Others want the JVM. Some just want a better
Java. Some just happen to use it for Spark.</p>

<p>I would choose the simpler Scala, the better Java. Trait-based generics, sum types, implicits, and
functional programming, to name a few. This is not just because it’s less complicated, from a
business perspective, it makes it easier to hire new programmers.</p>

<p>As a professional Scala developer and a long-time functional programming enthusiast, I fear that I
may never comfortably jump to another company, confident that since I’ve written Scala, I can
understand their Scala. That, or years of experience, but who knows what’s enough? Their, whoever
they may be, Scala might not be the simple Scala I and my colleagues prefer.</p>

<p>This is scary. For the future of the language, this is an untenable position. While I absolutely
enjoy working with the language, I’m afraid that it is fated to be like Macbeth from Shakespeare:
“thou shalt get kings, though thou be none”. Thus, Scala will inspire a great language and then
die. Maybe it already did, and the clock is ticking. Some purport Kotlin as the successor, but I
wouldn’t bet on it just yet.</p>

<blockquote>
  <p>“Ah, but a man’s reach should exceed his grasp, or what’s a heaven for?”</p>

  <p>—Robert Browning</p>
</blockquote>

<p>The thing about Scala is that this is a conscious design decision. The language is <em>meant</em> to have
everything and the kitchen sink. Programming languages don’t have to be simple. Powerful languages
are powerful tools. Use them well, you can achieve greatness. You have to <em>choose</em> your tool set and
hone it.</p>

<p>But for Haskell, Go, and Clojure, you’re using them, and you’re thinking, what is the natural way to
do this? Once you find it, you find yourself implementing ideas using that philosophy, that natural
way, and you’re no longer just using a tool. You’re using an <em>idea</em>.</p>

    </article>
    
    <article class="post">
        <header>
            <h1>
                <a class="post-title" href="/2016/03/17/imprecision-and-abstraction.html">Imprecision and abstraction</a>
            </h1>
            <p>
                <time class="text-muted post-meta" datetime="2016-03-17">
                    March 17, 2016
                    &mdash; Tagged as <a href="/tags/general">general</a>, <a href="/tags/fp">fp</a> 
                </time>
            </p>
        </header>
        <p>What is the point of abstractions?</p>

<p>We want to hide things. We want to generalize things. We want to extend things.</p>

<p>Why are mathematical abstractions so intractable? Why is the 
<a href="https://en.wikipedia.org/wiki/Functor">Wikipedia page on functors</a> incomprehensible to someone not
used to mathematical formalisms? Why does it sound so vague?</p>

<p>When approaching abstractions, for educational purposes, it is sometimes easier to think of
analogies or similes. We can conceptualize the idea of functors of “procedures” that operate on things inside
“boxes”, or we can study relational algebra using Venn diagrams.</p>

<p>These analogies are dangerous, because they are vague. Formalisms leave no room for interpretation
because they are exact not whimsically, but because of the pervasive imprecision of the human mind.</p>

<p>Let’s take an analogy that’s very approachable but quite dangerous. Explaining modular arithmetic
can done with clocks. The analogy would go like this:</p>

<blockquote>
  <p>You see, when you have a number modulo 12, think of it as a clock. If x is over 12, think
of like like the hand of a clock looping over, and you’re back where you started.</p>
</blockquote>

<p>The problem with such an analogy is that not everybody uses 12-hour clocks. Most of Europe uses a
24-hour clock with no distinction between AM and PM. Of course, they are also taught to understand
that “sixteen” means “four” since nobody builds 24-hour analog clocks (yet). That aside, it’s still
very possible, that when explaining the above analogy to someone accustomed to 24-hour clocks,
they’ll get confused since what comes after 12, is 13, not 0.</p>

<p>This is a basic but fundamental example: things like functors, semigroups, monads, and categories,
are a bit intractable for a reason: there’s no room left for interpretation.</p>

<p>Mathematical formalisms pare fundamental ideas into pure forms. Your intuition can’t get in the way
and corrupt them.</p>

<p>The obvious downside is that these formalisms are harder to understand. I wager that this is for the
better because down the road there are concepts so high-level one can’t even begin to think in
analogies, and it will only slow one down.</p>

<p>There was a turning point in my math studies when I stopped trying to grok things using
analogies. My approach to topology was geometrical. I tried to visualize
<a href="https://en.wikipedia.org/wiki/Limit_point">limit points</a> in my mind and in vain, because the mind
can’t bend itself around more than three spatial dimensions. Granted, visualizing
<a href="https://en.wikipedia.org/wiki/Hypercube">hypercubes</a> was possible (“like a cube is made of sides, a
hypercube is made of cubes”)… kind of.</p>

<p>Stopping this perilous habit, I started to memorize laws instead. That changed the language of maths
for me, forever. I wasn’t understanding relations via shapes or arrows, but by basic axioms and
mathematical laws. It wasn’t too long before I started to visualize concepts using these laws.</p>

<p>I stopped staring concepts in the eye, looking for hidden meanings behind
<a href="https://en.wikipedia.org/wiki/Bounded_set">bounded sets</a>. I simply read
the definition, thought “huh”, and memorized it. Slowly, by building towards other related concepts
and set theory I quickly understood what the law meant, without trying to grok the hidden meaning.</p>

<p>Once that became a habit, it became easy and changed my approach forever: let go of
intuition. Abstract ideas are hard by definition and they need to be understood piece by piece, from
the ground up.</p>

<p>This is why any explanation of a precise thought, like a mathematical formalism, using something
imprecise like an analogy, is a fallacy doomed to fail.</p>

<p>When functional programmers try to explain basic ideas like semigroups or functors, they often find
themselves in an apologetic mire of simplifications. This is doomed to fail. Give concrete examples
of how a functor works. Don’t illustrate them as operations that can map stuff in boxes to other
boxes. Invent a problem and solve it using a functor. After all, they’re such a basic concept, even
those writing non-functional code end up doing them all the time.</p>

<p>Let the abstraction sink in, it’s the only thing that will survive.</p>


    </article>
    
    <article class="post">
        <header>
            <h1>
                <a class="post-title" href="/2016/03/17/scala-expression-problem.html">Scala and the Expression Problem</a>
            </h1>
            <p>
                <time class="text-muted post-meta" datetime="2016-03-17">
                    March 17, 2016
                    &mdash; Tagged as <a href="/tags/plt">plt</a>, <a href="/tags/scala">scala</a> 
                </time>
            </p>
        </header>
        <p>I previously wrote about the <a href="/2016/01/08/the-expression-problem-as-a-litmus-test.html">expression problem in OCaml</a>, 
and I thought I’d continue the series and
talk about how the problem can be avoided in Scala. Unsurprisingly, the most idiomatic Scala
solution is actually quite unique and relies on sub-traits and trait inheritance.</p>

<p>Let’s rewind. The expression problem asks this:</p>

<blockquote>
  <p>The goal is to define a datatype by ases, where one can add new cases to the datatype and new
functions over the datatype, without recompiling existing code, and while retaining static type
safety (e.g., no casts).</p>
</blockquote>


    </article>
    


    <nav class="pagination" role="pagination">
    
    <span class="page-number"> Page 1 of 3 </span>
     
        <a class="older-posts" href="/page2/" title="Next Page">Older Posts &raquo;</a>
     
</nav>
    
</div>

                </div>
                
                <footer>
                    <hr>
                    <address>
                        Copyright &copy; 2016 <a href="">Antoine Kalmbach</a> under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>.
                    </address>
                </footer>
            </div>
            <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
            <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/js/bootstrap.min.js" integrity="sha384-vZ2WRJMwsjRMW/8U7i6PWi6AlO1L79snBrmgiDpgIWJ82z8eA5lenwvxbMV1PAh7" crossorigin="anonymous"></script>
            <script type="text/javascript" src="/assets/toc.min.js"></script>
            <script src="/assets/hyphenator.js" type="text/javascript"></script>
            <script src="/assets/hylo.js" type="text/javascript"></script>
            <!-- Google Analytics Tracking code -->
            <script type="text/javascript">

             var _gaq = _gaq || [];
             _gaq.push(['_setAccount', 'UA-58162697-1']);
             _gaq.push(['_trackPageview']);

             (function() {
                 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
             })();

            </script>   
        </div>
        </div>
        </div>
    </body>
</html>
