<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>Antoine Kalmbach - and his thoughts on programming</title>
    <meta name="description" content="Antoine speaks about software." />

    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Open+Sans:700,400|Merriweather:400,400italic,700,700italic,900,900italic" />
    <!-- Customisation  -->
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />

</head>
<body class="post-template">

    <header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        <a class="link" href="/">Home</a>
	<a class="link" href="/about.html">About</a>
        <a class="link" href="/rss.xml">Subscribe</a>
    </nav>
</header>

<main class="content" role="main">

    <article class="post">

        <header class="post-header">
            <h1 class="post-title">The Side-effects of Functional Programming</h1>
            <section class="post-meta">                
		<section class="tags">
		
		    
			<span>#functional-programming</span>
		    
			<span>#introductory</span>
		    
			<span>#haskell</span>
		    
			<span>#ocaml</span>
		    
		
		</section>
                <time class="post-date" datetime="2015-01-02">02 Jan 2015 by Antoine Kalmbach</time>
		
		<br/>
		
            </section>
        </header>

<!--         <header class="post-header">
            <a id="blog-logo" href="http://ane.iki.fi/">
                
                    <span class="blog-title">Antoine Kalmbach</span>
                 
            </a>
        </header> -->
        
        <!-- <span class="post-meta">
            <time datetime="2015-01-02">02 Jan 2015</time>
            
        </span> -->

        <!-- <h1 class="post-title">The Side-effects of Functional Programming</h1> -->

        <section class="post-content">
            <p>The lack of side-effects and immutability are definitive
characteristics of functional programming: its declarative modus
expresses clearly that variables cannot be altered after being
declared. How does understanding this style affect the writing of
ordinary imperative code, after the programmer, having learned and
understood immutable code, returns to imperative programming?</p>

<!--break-->

<p>Assuming a layperson, in this context a programmer with foundations in
imperative programming language but unfamiliar to functional
programming, starts to learn functional programming, there are a
multitude of interesting and completely foreign concepts on the way
ahead. Monads, type classes, higher-order functions, to name a few;
and of course side-effects and immutability. What exactly are
side-effects, and why is immutability important in functional
programming?</p>

<h2>Introduction: FP basics</h2>

<p>This article explains side-effects and immutability for someone
who isn&#39;t that familar with functional programming, and then goes
on to the main point, how knowledge of such features impacts writing
ordinary imperative code. Readers familiar with the topic can proceed
directly to the section titled &quot;Effects On The Programmer&quot;.</p>

<h3>There Are No Variables</h3>

<p>In functional languages, e.g., Haskell and OCaml (and the ML family),
no declared variable really is a variable, in the sense that their
value can <em>vary</em>.  They are all functions, a variable defined <code>let foo = 3</code>
is just a function that takes no parameters and returns the value
<code>3</code>. Because these languages rely on type inference, the compilers can
automatically deduce from looking at the returned type that foo is an
integer variable&mdash;that is to say, a function that <em>takes no
parameters</em> and returns an integer.</p>

<p>Since zero-parameter functions are functions, by the magic called
<em>currying</em>, any function with <code>n</code> parameters can be called with <code>n-1</code>
parameters, where n is greater than 0. To illustrate, the canonical
example <code>let plus a b = a + b</code> can be used in another function like
this: <code>let plusOne = plus 1</code>.  The type of plus is <code>int -&gt; int -&gt; int</code>,
which can be read as &quot;take an integer, another integer, and
produce an integer&quot;.  The type of <code>plusOne</code> is <code>int -&gt; int</code> since one
of its arguments has been fixed, calling <code>plus 1</code>
returns <em>a new function</em> with one fixed argument.</p>

<p>In fact, any function taking <code>n</code> arguments is actually just <code>n</code>
functions taking one argument each! Our canonical example <code>plusOne</code>
first returns a function taking the first argument <code>a</code>&mdash;which binds a
to a fixed value&mdash;and returns another function taking <code>b</code>,
whereby <code>a</code> is fixed, and returns <code>a + b</code>.</p>

<p>Since there really aren&#39;t any variables, just function calls, it
follows that variables cannot really be altered, <em>because they
aren&#39;t variables</em>. What does this mean?</p>

<h3>So It Shall Be Declared</h3>

<p>In imperative programming, mutable variables are everywhere. We
declare counters such as <code>i++</code> and rely on their steady updating all
the time. We fixing an index <code>i</code> that points somewhere in memory and
with each iteration the index is adjusted to an arbitrary direction,
commonly, one step ahead: <code>i++</code>. Or maybe we just need to do something
<code>n</code> times, print a string, update the counter.</p>

<p>Loops in functional programming work in a different way: they are
mappings, from one collection to another, when lists of integers are
morphed into a list of squares, or they are summed into a total. 
The principle of declaration is fundamental. Functional programmers
<em>say</em> that this result squared list is the application of a function
<code>square</code> on each of the members of another list, imperative
programming has us produce a square successively <code>n</code> times. In
functional programming, the upper limit <code>n</code> is trivial, in imperative
programming it is necessary.</p>

<p>Doing something <code>n</code> times in functional programming is tricky, because
the pattern is sometimes invalid. Any loop is fundamentally a
<em>mapping</em> from one source to another; a mapping without a target is
nonsensical. A common trick around this is to wrap the action in
something that conveys no value or simply discard the results, again,
no <code>i++</code> is necessary.</p>

<p>Because everything is <em>declared to be something</em>, a value, or a
function, or a mapping, these declarations remain steady and unchanged
throughout execution.  We fix the result of <code>squaredIntegers[]</code> to be
the result of a mapping, we cannot touch it afterwards.</p>

<p>In rough terms, our code cannot alter anything, it can only use those
variables known at its <em>moment of declaration</em>, i.e., what knowledge is
visible to it: the declared code that precedes it. Our code has no
side-effects, it only produces more values to be evaluated further.</p>

<p>So if we cannot have side-effects, then how do we interact with the
outside world?  How do we read files or write output to the screen?</p>

<h3>Schr√∂dinger&#39;s Monad and Feline Thunks</h3>

<p>If functions are read-only values, interacting with the outside world
will be difficult. Some languages, such as OCaml and F# let you readily
exit to the outside world and permit these kinds of side-effects (both
languages also allow explicit mutable variables), but Haskell encapsulates
any I/O into the IO monad, whereby any I/O actions are evaluated
at runtime, hence not having any effect at compile time, functions
are read-only values after all!</p>

<p>The IO encapsulation lets Haskell implement randomization, since
functions are <em>declared</em> to always return or act the same way, we must
wrap randomization into the IO monad because it tells us, among other
things, that this is to be evaluated at runtime. Values not evaluated
at compile time, or due to lazy evaluation at runtime, are known as
<em>thunks</em> in Haskell.</p>

<p>Because functions are declared to return the same result every time,
IO events are deemed &quot;unsafe&quot;, and hence the encapsulation lets us
perform unsafe computations inside a safe environment&mdash;in Haskell, the
IO monad.</p>

<p>In Haskell, to interact with the outside world, you must encapsulate
functions into a stateful computation, which the compiler understands
have runtime-only considerations. Other languages such as OCaml aren&#39;t
as strict and let you escape into the outside world whenever, and conveniently
has a type <code>unit</code> which essentially is a value that conveys no meaning,
much like the <code>void</code> of the C world.</p>

<p>To summarize, immutability and the lack of real side-effects are key
features in functional languages, while some languages allow it <em>explicitly</em>
(OCaml and F#, to name a few), in general, treat variables as read-only values
and build your expressions using that paradigm.</p>

<h2>Effects On The Programmer</h2>

<p>Functional code has to be written in a manner drastically different
from imperative programming, so much so that one of the biggest
burdens for a new programmer learning functional programming often
stumbles on the new paradigm. Let&#39;s imagine for a moment that our
novice goes into seclusion, becomes an intermediate functional
programmer, and after the monastic life, returns to
imperative programming. Will his coding style be affected?</p>

<p>What happens is truly anyone&#39;s guess, but I can tell you mine. I had
my first steps with OCaml some five years ago and then found Haskell
in university, where it baffled me and went over my head until I groked its beauty.
I learnt it on the side, and I later studied type theory and some
principles of programming languages, to understand how languages work
at a higher level.</p>

<p>I noticed a strange change in the way I code. Before I mentioned the
concept of &quot;moments of declaration&quot;, e.g.,</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">x</span> <span class="ow">=</span> <span class="mi">1</span>                              <span class="c1">-- x&#39;s moment of declaration</span>
<span class="nf">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span>                          <span class="c1">-- y&#39;s moment of declaration</span>
<span class="nf">bar</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">z</span> <span class="ow">-&gt;</span> <span class="n">z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="n">y</span><span class="p">]</span>  <span class="c1">-- bar&#39;s moment of declaration</span>
</code></pre></div>
<p>all of the values above see only anything that precedes them, nothing
that comes afterwards. This paradigm embeds itself deeply in the
programmer&#39;s mind, to the extent that it&#39;ll transform imperative code
to written in this style, in the &quot;let&quot; fashion.</p>

<h3>Context piling</h3>

<p>A key characteristic of this method is that <em>the current line you are
looking at counts</em>. Code readability improves tremendously, because
you can read it line-by-line and not ponder over the ever growing
context accumulated from the lines above&mdash;you see the variables, but
they are read-only definitions. This avoid what I call the <em>context
piling</em>, where code relies too much on its preceding blocks with
actual variables and mutated state.</p>

<p>Of course, functional languages also have contexts, where the values you are
looking at have some meaning defined above, but in functional programming,
the key difference is that <strong>the context is always defined before</strong>. The lack of side
effects is also subtly illustrated in the snippet above: <code>x</code> and <code>y</code> cannot
touch <code>bar</code>, and <code>bar</code>s semantics can be easily deduced by looking <em>up</em>.</p>

<p>In an imperative language, we may define a variable and assign values
to it, and over the course of the computation it may take new values,
one will always be looking in <em>two</em> directions. This leads to increased code entropy.</p>

<p>Functional programming affected my imperative object-oriented code in
this many striking fashions:</p>

<ol>
<li>Avoid side effects, prefer functions that return values,
<strong>especially</strong> in OOP, no byrefs<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>!</li>
<li>Minimize stateful objects, use objects as containers and
for encapsulation</li>
<li>If you need stateful objects, make it explicit and easy to understand</li>
<li>Use interfaces a bit like type classes, multiple inheritance <em>of
interfaces</em> is OK</li>
<li>Use structural typing if you can (stay away from duck typing)</li>
<li>Hijack method or function overloading to create a bastardized
pattern matching mechanism</li>
<li>Avoid context piling by let defining new variables with visible and clear moments of
declaration</li>
<li>Avoid <code>object.DoSomething()</code> </li>
<li>Rely on lazy evaluation and generators (<code>yield</code> in C# or Python)</li>
</ol>

<h2>Effects on quality</h2>

<p>I&#39;m not wise enough to comment on whether these changes constitute an
<em>improvement</em> on code quality. I have only noted the changes. Their
effect on the quality of my code is hard to evaluate. I&#39;ve noticed a
change in the workflow and the way I debug things, and also the kinds
of programming environments in which this style works better.</p>

<p>The style I&#39;ve gravitated to, in imperative programming, thrives in a
statically and strongly typed language, in dynamic and weakly typed
languages it is prone to requiring breakpoints.  This is easy to
explain. A coding style with lots of let statements has lots of
assignments and function calls, the return values are explicitly bound
to a certain type, a type checking compiler will spot any errors; the
only errors you may encounter are semantic, that is, the value you
might be expecting is semantically nonsensical&mdash;the square of an
integer turns out to be -4, or something equally silly&mdash;but is
always correct in terms of typing. Semantic bugs are <em>much</em> easier to
correct&mdash;and debug&mdash;than undefined behaviour.</p>

<p>In a dynamic language, where variables can arbitrarily change their
type, e.g. JavaScript, Python, or even C, this isn&#39;t as easy, as the
compiler won&#39;t be there to do type checking. If anything, I&#39;ve learnt
that dynamic typing is idiotic, and languages that are designed with
dynamic weak typing are terrible. Thankfully, new languages seem to be
following the static typing school of thought (Go, Rust, Swing, Nim).</p>

<h1>Conclusion</h1>

<p>Functional programming imposes a new paradigm of programming on the
programmer, and this style has considerable side-effects on the way
our programmer writes imperative code. In this article, I outlined
what these changes were&mdash;based on my experiences&mdash;I await
the reactions of others to see whether my observations were true to
them as well. The side-effects I mentioned more or less resulted in
imperative code borrowing the good parts of functional programming and
throwing away the bad parts of imperative programming.</p>

<p>It is much harder to judge if these changes led to improvements, since
code quality is difficult to judge. I will follow up on this in an
upcoming post where I will discuss code entropy and code scalability,
and how the composability of functional programming may be used to fix
this. For now, to make a valid assertion on code quality I need
more data.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>No mutable parameters, e.g., <code>out parameter</code> in C#&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

        </section>

        

        <footer class="post-footer">
            <!-- If we want to display author's name and bio -->
            
                <figure class="author-image">
                    <a class="img" href="/" style="background-image: url(/assets/images/profile.png)">
                    <span class="hidden">Antoine Kalmbach's Picture</span></a>
                </figure>
                <section class="author">
                    <!-- Author Name -->
                    <h4> Antoine Kalmbach </h4>
                    <!-- Author Bio -->
                    <p> 
                        A Finnish software engineer from Jyv√§skyl√§, Finland.
                    </p>
                </section>                
            

            <!-- Share links section -->
            <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?text=The Side-effects of Functional Programming&amp;url=http://ane.iki.fi//2015/01/02/side-effects-of-functional-programming.html"
        onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://ane.iki.fi//2015/01/02/side-effects-of-functional-programming.html"
        onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=http://ane.iki.fi//2015/01/02/side-effects-of-functional-programming.html"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>
            
            <!-- Disqus comments -->
            
            
        </footer>

    </article>

</main>

    <footer class="site-footer clearfix">
      <section class="copyright">
        <a href="/">Antoine Kalmbach</a> &copy; 
               &bull; All rights reserved.
      </section>
      <section class="poweredby">Made with Jekyll using 
        <a href="http://github.com/rosario/kasper">Kasper theme</a>
      </section>
    </footer>
    
    <script type="text/javascript" src="/assets/js/jquery-1.11.1.min.js"></script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>

    <!-- Google Analytics Tracking code -->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-XXXXXXXX-X']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>   
</body>
</html>
