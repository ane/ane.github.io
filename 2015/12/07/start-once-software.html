<!-- -*- engine:liquid -*- -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <link href="https://micro.blog/ane" rel="me" />
    <link rel="webmention" href="https://micro.blog/webmention" />

    <title>
      
        Start-once software
      
    </title>

    
      <meta name="description" content="Our development tools are transitioning away from batch oriented processing">
    
    <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml" />

    <link type="application/atom+xml" rel="alternate" href="http://ane.iki.fi/feed.xml" title="Antoine Kalmbach's website" />
    <meta http-equiv="refresh" content="0; url=http://ane.iki.fi/2015/12/07/start-once-software.html" />
    <link rel="canonical" href="http://ane.iki.fi/2015/12/07/start-once-software.html"/>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Start-once software | Antoine Kalmbach’s website</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Start-once software" />
<meta name="author" content="Antoine Kalmbach" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Software development tools are in a state of flux. There are two competing directions towards which static analysis tools—like linters and type checkers—are heading. The traditional direction is to operate in a batch model. Fire up, perform analysis, report results, and die. This is a proven method. Batch-oriented software has been around for ages, and it works really well if the data you’re working with isn’t large." />
<meta property="og:description" content="Software development tools are in a state of flux. There are two competing directions towards which static analysis tools—like linters and type checkers—are heading. The traditional direction is to operate in a batch model. Fire up, perform analysis, report results, and die. This is a proven method. Batch-oriented software has been around for ages, and it works really well if the data you’re working with isn’t large." />
<link rel="canonical" href="http://ane.iki.fi/2015/12/07/start-once-software.html" />
<meta property="og:url" content="http://ane.iki.fi/2015/12/07/start-once-software.html" />
<meta property="og:site_name" content="Antoine Kalmbach’s website" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-12-07T12:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Start-once software" />
<meta name="twitter:site" content="@anewtf" />
<meta name="twitter:creator" content="@Antoine Kalmbach" />
<script type="application/ld+json">
{"headline":"Start-once software","dateModified":"2017-04-13T10:11:04+00:00","datePublished":"2015-12-07T12:00:00+00:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://ane.iki.fi/2015/12/07/start-once-software.html"},"url":"http://ane.iki.fi/2015/12/07/start-once-software.html","author":{"@type":"Person","name":"Antoine Kalmbach"},"description":"Software development tools are in a state of flux. There are two competing directions towards which static analysis tools—like linters and type checkers—are heading. The traditional direction is to operate in a batch model. Fire up, perform analysis, report results, and die. This is a proven method. Batch-oriented software has been around for ages, and it works really well if the data you’re working with isn’t large.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/override.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="/assets/pygments.css" type="text/css" media="screen" />
  </head>
  <body itemscope itemtype="https://schema.org/WebPage" class="home-template">
    <div class="hyphenate">
      <h1 style="text-align: center;">
  Antoine Kalmbach
</h1>
<nav class="navbar">
  <ul>
    <li class="nav-item ">
      <a class="nav-link pl-0" href="/" itemprop="url"><span itemprop="name">Home</span></a>
    </li>
    <li class="nav-item  active">
      <a class="nav-link" href="/archive.html" itemprop="url"><span itemprop="name">Blog</span></a>
    </li>
    <li class="nav-item ">
      <a class="nav-link" href="/about/" itemprop="url"><span itemprop="name">About</span></a>
    </li>
    <li class="nav-item ">
      <a class="nav-link" href="/tags.html" itemprop="url"><span itemprop="name">Index</span></a>
    </li>

    <li class="nav-item mr-n2">
      <a class="nav-link" href="/feed.xml"><i class="fa fa-rss" aria-hidden="true"></i> RSS</a>
    </li>
  </ul>
</nav>

<div class="h-card d-none" style="display: none">
  <img class="u-photo" src="/images/me.png" />
  <a class="u-url" href="http://ane.iki.fi/2015/12/07/start-once-software.html"></a>
  <a class="p-name u-url" href="http://ane.iki.fi">Antoine Kalmbach</a>
  <a class="u-email" href="mailto:">ane@iki.fi</a>
</div>


      <div class="content">
        <article class="h-entry">
  <header>
    





  <h2 class="p-name" style="margin: 0.25rem 0;">
    Start-once software
  </h2>

  <p class="post-meta text-muted">
    <time class="dt-published" itemprop="datePublished" datetime="2015-12-07 12:00:00 +0000">
      Posted on December 7, 2015

  </p>


    <link itemprop="mainEntityOfPage" itemscope itemtype="http://schema.org/BlogPosting" href="/2015/12/07/start-once-software.html" />
  </header>
  <div class="e-content">
    <p>Software development tools are in a state of flux. There are two competing
directions towards which static analysis tools—like linters and
type checkers—are heading.</p>

<p>The traditional direction is to operate in a <em>batch</em> model. Fire up, perform analysis, report
results, and die. This is a proven method. Batch-oriented software has been around for ages, and it
works really well if the data you’re working with isn’t large.<!--break--></p>

<p>The new direction is an <em>online</em> model: an analysis tool starts, calculates its
data, reports results, and then stays <em>on</em>, monitoring for changes. When changes
occur, the program analyzes the changes, and recomputes the effects. This
execution model is efficient: incremental updates are easier to calculate than
starting from scratch. This approach is arguably more modern<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote">1</a></sup>, since we’re
leveraging the full potential of a client-server model.</p>

<p>The obvious caveat is such a process will eat up memory. These days this is
becoming less and less of a problem, since a gigabyte of desktop-quality DDR3
memory costs about <a href="http://www.newegg.com/Product/Product.aspx?Item=N82E16820231314&amp;cm_re=ddr3-_-20-231-314-_-Product">US$5</a>.</p>

<p>However, if the workload is large, say 100k-1M lines, it actually makes more
sense to compute an initial “model” of the system, and then <em>incrementally</em>
update the model when the system changes.</p>

<p>My line of reasoning was inspired by <a href="https://news.ycombinator.com/item?id=10271755">this comment on Hacker News</a>:</p>

<blockquote>
  <p>Over and over I see reports of iteration speed being critical to
real-world projects, and that’s certainly my experience.</p>

  <p>But it’s something I rarely see featured in tool design. So many of
our tools are still batch oriented: they start from scratch, read
everything, process everything, and then exit. That made sense in an
era where RAM and CPU were expensive. But now that they’re cheap, I
want tools that I start when I arrive in the morning and kill when I
go home. In between, they should work hard to make my life easy.</p>

  <p>If I’m going to use a type checker, I want it to load the AST once,
continuously monitor for changes, and be optimized for incremental
changes. Ditto compilers, syntax checkers, linters, test runners,
debugging tools. Everything that matters to me in my core feedback
loop of writing a bit of code and seeing that it works.</p>

  <p>For 4% of my annual salary, I can get a machine with 128GB of RAM and
8 3.1 GHz cores. Please god somebody build tools that take advantage
of that.</p>
</blockquote>

<p>Arguably, the batch mode made sense in the past, when resources weren’t as
plentiful as they are now. Now, we can afford a type checker that sits in the
background, eating up half a gigabyte memory, and most of us won’t even <em>blink</em>
at that, as long as it helps us write better code—and runs quickly.</p>

<p>To this end, one could call such software <em>start-once software</em><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup>, which</p>

<ol>
  <li>Is launched <strong>once</strong>, via some mechanism and given a target, e.g. a codebase, to
monitor for changes</li>
  <li>Computes an initial <strong>model</strong>, the analysis, of the target</li>
  <li>Whenever changes occur it instantly <strong>recomputes</strong> a new model and informs
the user of the effects of the changes.</li>
</ol>

<p>In this case, the target could be a collection of source files (a “project”), 
the model the compilation errors present in the source files, and the relevance
is a way of communicating those errors to the user.</p>

<p>The basic idea can be taken from Facebook’s <a href="http://www.flowtype.org">Flow</a>
which does exactly this when you launch it initially, it boots up a server that
keeps the state of the AST in memory. The server runs the analysis and the client
reports the results. There’s an initial up-front cost to all of this from
starting the server but subsequent calls are fast.</p>

<p>There are some pseudo-implementations of this paradigm: you can have a batch
process that is run every time the target changes, and then do effectively what
is done in step three above. This is <em>kind of</em> what I described above, but the
difference is that any model is lost inbetween batch runs.</p>

<p>In fact, file system notification based batch processes remind<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote">3</a></sup> me of the
<a href="https://en.wikipedia.org/wiki/The_Chinese_Room">the Chinese room experiment</a>:
such tools don’t really have an <em>understanding</em> of the model that is
<strong>persistent</strong>, but due to a simultaneously crude and brilliant approach, we get the
subtle impression that such a persistent, evolving understanding actually exists.</p>

<p>In start-once software, the goal is to always keep the model in working memory
and update it incrementally. Such a program can react quickly to massive
codebase changes. Naturally, speed comes at the cost of memory, but as mentioned
in the quote, if it makes development faster, I think this is a perfectly
justifiable cost.</p>

<p>This line of thinking doesn’t apply only to static analysis tools. It can work
with any streaming data. Memory is cheap, but speed always isn’t. A good example
is a log processor that computes the state of some system based on the content
of some logs. A start-once processor would continuously monitor the log inputs
and update its model of the system. If it has to churn through a lot of logs at
the start, it may have an initial delay but because the model is persistent, any
changes to the model can be computed quickly.</p>

<p>Storing the model can be done in two ways. If RAM becomes a limitation (will
it?), a fast database should be used. AFter all, databases <em>solely</em> exist
because of the prohibitively high cost of ephemeral memory compared to the cost
of non-volatile memory. Traditionally!</p>

<p>Previously, because of the cost of ephemeral memory, we had to invent a cheaper
form of storage. Now that memory is cheap, this isn’t so much of a threat
anymore.</p>

<p>When it comes to fault-tolerance, precautions can be taken. The model could be
stored as a persistent image—yes, raw memory or an accurate representation
thereof, or a database. Once the program recovers, it restores the model
immediately, reducing the boot time.</p>

<p>This model also be extended to web servers: instead of recompiling everything at
every request (hello PHP), one could compile <em>once</em> and then compile changes
incrementally. This idea isn’t new: <em>hot swapping</em> has been around for decades,
and its advantages are obvious. Heavy-duty services that take a while to reload
and restore benefit massively of hot swapping. This is routine in the JVM,
Erlang and Lisp worlds.</p>

<p>Instead of shutting down your engine to upgrade it, you simply replace the parts
to be upgraded with new ones.</p>

<p>Extending this to static analysis tools isn’t a massive step. If the philosophy
works with server programs I see no reason why it couldn’t work with data
analysis tools. At the cost of ephemeral resources like memory, I want static
analysis tools that can handle large codebases and compute any change big or
small in a fraction of a section.</p>

<p>I hope more tools will adopt this model. We certainly do have the resources now.</p>

<h2 id="addendum-examples-of-start-once-static-analysis-tools">Addendum: examples of start-once static analysis tools</h2>

<h3 id="flow"><a href="http://flowtype.org">Flow</a></h3>

<p>A static analysis tool for JavaScript by Facebook, written in OCaml. Upon
launch, it starts a server that runs initial analysis and monitors for
changes.</p>

<h3 id="hack"><a href="http://hacklang.org/">Hack</a></h3>

<p>A PHP-inspired gradually typed programming language for the HHVM virtual
machine. It runs a type checker in the background in the same way as Flow
does. Also in OCaml!</p>

<h3 id="gocode"><a href="http://github.com/nsf/gocode">gocode</a></h3>

<p>Auto-completion service for Go. It uses a client-server model where completion
requests are sent to the completion server via a JSON-based RPC. Conversely,
every other Go-related static analysis tool
(<a href="http://dominik.honnef.co/posts/2014/12/an_incomplete_list_of_go_tools/">there are lots</a>)
is using the batch approach. That’s fine, since Go seems to be vehemently
opposed to anything modern and advanced, and <em>sometimes</em> justifiably so. In this
regard Gocode is a rare gem among the Go tooling ecosystem.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:3" role="doc-endnote">
      <p>Yes, I know REPLs have been around since the eighties, but this isn’t exactly the same thing. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Facebook uses the term “online” when describing Flow <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>They aren’t <em>exactly</em> the same thing. Since I’m talking about computer programs performing some kind of data analysis, and mentioning the Chinese room experiment, I realize that I’m opening a massive can of worms; the comparison is a mere <em>simile</em> here. The users of continuous (i.e. inotify-based) batch analysis tools are on the observing end of the Chinese room experiment. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>
  <small style="display: flex; justify-content: space-between;">
    

    
      <em>
        Next: <a href="/2016/01/01/before-we-begin.html">Before we begin</a>
      </em>
    
  </small>
</article>

      </div>

      <footer>
        <hr>
        <address>
          
          

          &copy; <a href="mailto:ane@iki.fi">Antoine Kalmbach</a>, see <a href="/this-site/index.html#copying">copying</a>.
          Last updated on <a href="/changelog.html">July 28, 2021</a>. Discuss at my <a href="https://lists.sr.ht/~ane/public-inbox">public inbox</a>.
        </address>
      </footer>
    </div>
    <script src="/assets/hyphenator.js" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [ ['$','$'], ['\\(', '\\)'] ],
         processEscapes: false
       }
     });
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <script src="/assets/hylo.js" type="text/javascript"></script>
    <!-- Google Analytics Tracking code -->
    <script type="text/javascript">

     var _gaq = _gaq || [];
     _gaq.push(['_setAccount', 'UA-58162697-1']);
     _gaq.push(['_trackPageview']);

     (function () {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
     })();

    </script>
  </body>

</html>
